<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王子泰</title>
  
  <subtitle>哭也欢乐，悲也潇洒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wang22ti.com/"/>
  <updated>2018-04-20T02:24:26.185Z</updated>
  <id>http://wang22ti.com/</id>
  
  <author>
    <name>wang22ti</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>北京交通大学第十一届大学生程序设计竞赛（重现赛）</title>
    <link href="http://wang22ti.com/2018/04/20/%E5%8C%97%E4%BA%AC%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88%E9%87%8D%E7%8E%B0%E8%B5%9B%EF%BC%89/"/>
    <id>http://wang22ti.com/2018/04/20/北京交通大学第十一届大学生程序设计竞赛（重现赛）/</id>
    <published>2018-04-20T02:24:26.000Z</published>
    <updated>2018-04-20T02:24:26.185Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编译原理》实验1-词法分析器的python实现</title>
    <link href="http://wang22ti.com/2018/04/20/%E3%80%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8B%E5%AE%9E%E9%AA%8C1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wang22ti.com/2018/04/20/《编译原理》实验1-词法分析器的python实现/</id>
    <published>2018-04-20T02:21:49.000Z</published>
    <updated>2018-04-20T02:21:49.736Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《操作系统》实验3-进程同步</title>
    <link href="http://wang22ti.com/2018/04/20/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AE%9E%E9%AA%8C3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://wang22ti.com/2018/04/20/《操作系统》实验3-进程同步/</id>
    <published>2018-04-20T01:10:21.000Z</published>
    <updated>2018-04-20T01:10:21.982Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《计算机体系结构》实验2.1-MIPS指令集编程之冒泡排序</title>
    <link href="http://wang22ti.com/2018/04/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E3%80%8B%E5%AE%9E%E9%AA%8C2-1-MIPS%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://wang22ti.com/2018/04/20/《计算机体系结构》实验2-1-MIPS指令集编程之冒泡排序/</id>
    <published>2018-04-19T16:02:56.000Z</published>
    <updated>2018-04-20T01:08:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-学习过程"><a href="#1-学习过程" class="headerlink" title="1 学习过程"></a>1 学习过程</h1><p>​        第一次写MIPS指令集程序，于是我从简单到复杂地写了4个程序<code>helloworld</code>, <code>testio</code>, <code>swap</code>, <code>bubblesort_noinput</code>并在<code>PCSpim</code>环境（使用教程见参考文献4和5）中运行，由于时间限制，最终实现了不具有输入的冒泡排序程序。</p><h1 id="2-hello-world程序"><a href="#2-hello-world程序" class="headerlink" title="2 hello world程序"></a>2 hello world程序</h1><p>​        该程序验证环境可用性，初步了解MIPS汇编语法，无须赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">str:    .asciiz &quot;hello world!\n &quot;</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">        .globl main</span><br><span class="line">main:</span><br><span class="line">        la $a0,str      # 打印一个字符串</span><br><span class="line">        li $v0,4</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        li $v0,10</span><br><span class="line">        syscall         # exit</span><br></pre></td></tr></table></figure><p><img src="/2018/04/20/《计算机体系结构》实验2-1-MIPS指令集编程之冒泡排序/image1.png" alt=""></p><h1 id="3-testio程序"><a href="#3-testio程序" class="headerlink" title="3 testio程序"></a>3 testio程序</h1><p>​        该程序实现输出输入的整数，初步了解MIPS汇编程序的syscall机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">str:    .asciiz &quot;please input a num: &quot;</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">        .globl main</span><br><span class="line">main:</span><br><span class="line">        la $a0,str      # 打印一个字符串</span><br><span class="line">        li $v0,4</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        li $v0, 5# 读取一个整数</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        move $a0, $v0# 打印一个数</span><br><span class="line">        li   $v0, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        li $v0,10</span><br><span class="line">        syscall         # exit</span><br></pre></td></tr></table></figure><p><img src="/2018/04/20/《计算机体系结构》实验2-1-MIPS指令集编程之冒泡排序/image2.png" alt=""></p><h1 id="4-swap程序"><a href="#4-swap程序" class="headerlink" title="4 swap程序"></a>4 swap程序</h1><p>​        该程序在testio的基础上实现比较两个数并交换为由小到大排序，为冒泡排序的实现做准备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">array:  .word 5, 4</span><br><span class="line">str_old:    .asciiz &quot;old array:\n&quot;</span><br><span class="line">str_new:    .asciiz &quot;new array:\n&quot;</span><br><span class="line">blank:      .asciiz &quot; &quot;</span><br><span class="line">enter:      .asciiz &quot;\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">        .globl main</span><br><span class="line">main:</span><br><span class="line">        la $a0,str_old  # 打印一个字符串</span><br><span class="line">        li $v0,4</span><br><span class="line">        syscall</span><br><span class="line">        jal print_array      # 跳转，并将地址保存在$ra用来返回</span><br><span class="line"></span><br><span class="line">        jal swap</span><br><span class="line"></span><br><span class="line">        la $a0,str_new  # 打印一个字符串</span><br><span class="line">        li $v0,4</span><br><span class="line">        syscall</span><br><span class="line">        jal print_array      # 跳转，并将地址保存在$ra用来返回</span><br><span class="line"></span><br><span class="line">        li $v0,10</span><br><span class="line">        syscall         # exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_array:</span><br><span class="line">        li $a1, 2       # 设置循环计数初值</span><br><span class="line">        la $a2, array   # 指针初始化</span><br><span class="line">loop1:  blez $a1, over1       # 如果$a1 &lt;= 0，跳转到retmain</span><br><span class="line">        lw   $a0, 0($a2)        # 将$a2对应的值取到$a0</span><br><span class="line">        li   $v0, 1             # 打印$a0的值</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        la $a0, blank              # 打印空格</span><br><span class="line">        li $v0, 4</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        addi $a2, $a2, 4        # 指针+1</span><br><span class="line">        addi $a1, $a1, -1       # 循环计数减一</span><br><span class="line">        j loop1</span><br><span class="line">over1:</span><br><span class="line">        la $a0, enter           # 打印一个换行</span><br><span class="line">        li $v0, 4</span><br><span class="line">        syscall</span><br><span class="line">        j retmain</span><br><span class="line"></span><br><span class="line">swap:</span><br><span class="line">        la $a2, array           # 指针初始化</span><br><span class="line">        addi $a3, $a2, 4        # 指针初始化</span><br><span class="line">        lw $t0, 0($a2)          # 将$a2对应的值取到$t0</span><br><span class="line">        lw $t1, 0($a3)          # 将$a3对应的值取到$t1</span><br><span class="line"></span><br><span class="line">        bge $t1, $t0, retmain   # 如果顺序，返回</span><br><span class="line">        sw $t0, 0($a3)          # 逆序，交换</span><br><span class="line">        sw $t1, 0($a2)</span><br><span class="line">        j retmain</span><br><span class="line"></span><br><span class="line">retmain:</span><br><span class="line">        jr $ra          # 返回主程序</span><br></pre></td></tr></table></figure><p><img src="/2018/04/20/《计算机体系结构》实验2-1-MIPS指令集编程之冒泡排序/image3.png" alt=""></p><h1 id="5-bubblesort-noinput程序"><a href="#5-bubblesort-noinput程序" class="headerlink" title="5 bubblesort_noinput程序"></a>5 bubblesort_noinput程序</h1><p>​        该程序在swap程序的基础上修改，利用指针的思想加入两层循环的控制，实现了冒泡排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">array:  .word 3, 1, 5, 3, 6</span><br><span class="line">str_old:    .asciiz &quot;old array:\n&quot;</span><br><span class="line">str_new:    .asciiz &quot;new array:\n&quot;</span><br><span class="line">blank:      .asciiz &quot; &quot;</span><br><span class="line">enter:      .asciiz &quot;\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">        .globl main</span><br><span class="line">main:</span><br><span class="line">        la $a0,str_old  # 打印一个字符串</span><br><span class="line">        li $v0,4</span><br><span class="line">        syscall</span><br><span class="line">        jal print_array      # 跳转，并将地址保存在$ra用来返回</span><br><span class="line"></span><br><span class="line">        jal sort</span><br><span class="line"></span><br><span class="line">        la $a0,str_new  # 打印一个字符串</span><br><span class="line">        li $v0,4</span><br><span class="line">        syscall</span><br><span class="line">        jal print_array      # 跳转，并将地址保存在$ra用来返回</span><br><span class="line"></span><br><span class="line">        li $v0,10</span><br><span class="line">        syscall         # exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_array:</span><br><span class="line">        li $a1, 5       # 设置循环计数初值</span><br><span class="line">        la $a2, array   # 指针初始化</span><br><span class="line">loop1:  blez $a1, over1       # 如果$a1 &lt;= 0，跳转到retmain</span><br><span class="line">        lw   $a0, 0($a2)        # 将$a2对应的值取到$a0</span><br><span class="line">        li   $v0, 1             # 打印$a0的值</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        la $a0, blank              # 打印空格</span><br><span class="line">        li $v0, 4</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        addi $a2, $a2, 4        # 指针+1</span><br><span class="line">        addi $a1, $a1, -1       # 循环计数减一</span><br><span class="line">        j loop1</span><br><span class="line">over1:</span><br><span class="line">        la $a0, enter           # 打印一个换行</span><br><span class="line">        li $v0, 4</span><br><span class="line">        syscall</span><br><span class="line">        j retmain</span><br><span class="line"></span><br><span class="line">sort:</span><br><span class="line">        la $a1, array           # 外层指针初始化</span><br><span class="line">        addi $t4, $a1, 16       # 外层尾指针初始化</span><br><span class="line">loop_out:</span><br><span class="line">        la $a2, array           # 内层指针初始化</span><br><span class="line">        sub $t3, $t4, $a1        # 内层尾指针初始化</span><br><span class="line">        addu $t5, $a1, $t3</span><br><span class="line">loop_in:</span><br><span class="line">        addi $a3, $a2, 4        # 指针初始化</span><br><span class="line">        lw $t0, 0($a2)          # 将$a2对应的值取到$t0</span><br><span class="line">        lw $t1, 0($a3)          # 将$a3对应的值取到$t1</span><br><span class="line"></span><br><span class="line">        bge $t1, $t0, next_loop   # 如果顺序，返回</span><br><span class="line">        sw $t0, 0($a3)          # 逆序，交换</span><br><span class="line">        sw $t1, 0($a2)</span><br><span class="line"></span><br><span class="line">next_loop:</span><br><span class="line">        addi $a2, $a2, 4        # 内层指针++</span><br><span class="line">        bne $t4, $a2, loop_in   # 判断内层指针是否指向尾指针</span><br><span class="line">        addi $a1, $a1, 4        # 外层指针++</span><br><span class="line">        bne $t5, $a1, loop_out  # 判断外层指针是否指向尾指针</span><br><span class="line">        j retmain               # 排序结束，返回</span><br><span class="line"></span><br><span class="line">retmain:</span><br><span class="line">        jr $ra          # 返回主程序</span><br></pre></td></tr></table></figure><p><img src="/2018/04/20/《计算机体系结构》实验2-1-MIPS指令集编程之冒泡排序/image4.png" alt=""></p><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6 参考资料"></a>6 参考资料</h1><p>[1]【十分钟教会你汇编】MIPS编程入门  <a href="https://blog.csdn.net/king523103/article/details/45967991" target="_blank" rel="noopener">https://blog.csdn.net/king523103/article/details/45967991</a></p><p>[2] MIPS编程实例集锦(1)  <a href="https://wenku.baidu.com/view/ec9f638583d049649b66588b.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ec9f638583d049649b66588b.html</a></p><p>[3] MIPS汇编：冒泡排序 <a href="https://blog.csdn.net/linwh8/article/details/68944058" target="_blank" rel="noopener">https://blog.csdn.net/linwh8/article/details/68944058</a></p><p>[4] 非常简单的MIPS小工具-SPIM <a href="https://blog.csdn.net/makethyme/article/details/6277769" target="_blank" rel="noopener">https://blog.csdn.net/makethyme/article/details/6277769</a></p><p>[5] PCspim的安装及使用操作 <a href="https://blog.csdn.net/Kiloveyousmile/article/details/69055131" target="_blank" rel="noopener">https://blog.csdn.net/Kiloveyousmile/article/details/69055131</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-学习过程&quot;&gt;&lt;a href=&quot;#1-学习过程&quot; class=&quot;headerlink&quot; title=&quot;1 学习过程&quot;&gt;&lt;/a&gt;1 学习过程&lt;/h1&gt;&lt;p&gt;​        第一次写MIPS指令集程序，于是我从简单到复杂地写了4个程序&lt;code&gt;helloworl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04远程桌面设置</title>
    <link href="http://wang22ti.com/2018/04/15/Ubuntu16-04%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/"/>
    <id>http://wang22ti.com/2018/04/15/Ubuntu16-04远程桌面设置/</id>
    <published>2018-04-15T03:17:26.000Z</published>
    <updated>2018-04-15T03:17:26.190Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《虚拟化与云计算》学习</title>
    <link href="http://wang22ti.com/2018/04/13/%E3%80%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E3%80%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wang22ti.com/2018/04/13/《虚拟化与云计算》学习/</id>
    <published>2018-04-13T02:56:53.000Z</published>
    <updated>2018-04-20T00:48:05.414Z</updated>
    
    <content type="html"><![CDATA[<p>嘉哥要做一个简单的云盘，所以就一步一步来吧。</p><h1 id="1-FTP"><a href="#1-FTP" class="headerlink" title="1 FTP"></a>1 FTP</h1><p>#1.1 FTP命令行上传下载</p><p>嘉哥用阿里云开了一台云服务器，安装了ftp服务器，打开了端口，关闭了用户验证，于是我就可以用匿名（Anonymous）的方式登录。解释参见<a href="https://jingyan.baidu.com/article/fdbd4277d8a4f7b89e3f48ab.html" target="_blank" rel="noopener">百度经验：怎样在命令行中使用FTP</a></p><p><img src="/2018/04/13/《虚拟化与云计算》学习/屏幕截图(540" alt="">.png)</p><p>下载需要使用<code>LITERAL PASV</code>设置为被动模式，具体参见<a href="https://blog.csdn.net/wxqian25/article/details/16821333" target="_blank" rel="noopener">ftp错误150 Opening ASCII mode data connection for /bin/ls.</a>以及<a href="https://bbs.csdn.net/topics/310044648/" target="_blank" rel="noopener">CMD里的FTP命令，怎么切换FTP的主被动模式？</a></p><p>默认下载目录为c:\user\45504，其中45504是我的用户名。</p><p><img src="/2018/04/13/《虚拟化与云计算》学习/屏幕截图(543" alt="">.png)</p><h1 id="1-2-python的FTP库ftplib上传"><a href="#1-2-python的FTP库ftplib上传" class="headerlink" title="1.2 python的FTP库ftplib上传"></a>1.2 python的FTP库ftplib上传</h1><p>有了上面的过程，python代码也很好理解啦，使用python自带的<code>ftplib</code>库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP</span><br><span class="line"></span><br><span class="line">ip = <span class="string">'101.200.57.174'</span></span><br><span class="line">user = <span class="string">'Anonymous'</span></span><br><span class="line">password = <span class="string">'wang22ti@163.com'</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'wang22ti.docx'</span></span><br><span class="line"></span><br><span class="line">ftp = FTP()</span><br><span class="line">ftp.set_pasv(<span class="keyword">False</span>)</span><br><span class="line">ftp.set_debuglevel(<span class="number">2</span>)</span><br><span class="line">ftp.connect(ip)</span><br><span class="line">ftp.login(user, password)</span><br><span class="line">print(ftp.getwelcome())</span><br><span class="line">ftp.storbinary(<span class="string">'STOR %s'</span> % file_name, open(file_name, <span class="string">'rb'</span>))</span><br></pre></td></tr></table></figure><p>其中<code>ftp.set_debuglevel</code>设置日志等级，<code>ftp.storbinary</code>以二进制的方式打开文件并上传。</p><p><code>ftp.set_pasv</code>比较复杂，详情参见<a href="http://blog.sina.com.cn/s/blog_9f6591a30101cj5r.html" target="_blank" rel="noopener">纯真的花花牛的博客</a></p><p><strong>然而还没完！</strong></p><p>当上传中文文件名的时候，出现了问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:/45504/Documents/MiCloud/Coding/python/虚拟化与云计算/test_ftp.py&quot;, line 15, in &lt;module&gt;</span><br><span class="line">    ftp.storbinary(&apos;STOR %s&apos; % file_name, open(file_name, &apos;rb&apos;))</span><br><span class="line">  File &quot;C:\Users\45504\AppData\Local\Programs\Python\Python35\lib\ftplib.py&quot;, line 503, in storbinary</span><br><span class="line">    with self.transfercmd(cmd, rest) as conn:</span><br><span class="line">  File &quot;C:\Users\45504\AppData\Local\Programs\Python\Python35\lib\ftplib.py&quot;, line 398, in transfercmd</span><br><span class="line">    return self.ntransfercmd(cmd, rest)[0]</span><br><span class="line">  File &quot;C:\Users\45504\AppData\Local\Programs\Python\Python35\lib\ftplib.py&quot;, line 382, in ntransfercmd</span><br><span class="line">    resp = self.sendcmd(cmd)</span><br><span class="line">  File &quot;C:\Users\45504\AppData\Local\Programs\Python\Python35\lib\ftplib.py&quot;, line 271, in sendcmd</span><br><span class="line">    self.putcmd(cmd)</span><br><span class="line">  File &quot;C:\Users\45504\AppData\Local\Programs\Python\Python35\lib\ftplib.py&quot;, line 198, in putcmd</span><br><span class="line">    self.putline(line)</span><br><span class="line">  File &quot;C:\Users\45504\AppData\Local\Programs\Python\Python35\lib\ftplib.py&quot;, line 193, in putline</span><br><span class="line">    self.sock.sendall(line.encode(self.encoding))</span><br><span class="line">UnicodeEncodeError: &apos;latin-1&apos; codec can&apos;t encode characters in position 5-7: ordinal not in range(256)</span><br></pre></td></tr></table></figure><p>昂，原因是<code>latin-1</code>的编码方式，看起来就不支持中文，打开最后一个报错地址可以看到最后发消息是以<code>self.encoding</code>的方式编码的：</p><p><img src="/2018/04/13/《虚拟化与云计算》学习/Snipaste_2018-04-13_11-54-53.png" alt=""></p><p>本以为找到它修改为<code>utf-8</code>就好了，结果又发生了新的错误：</p><p><img src="/2018/04/13/《虚拟化与云计算》学习/1523593140997.png" alt=""></p><p>百思不得其解，<a href="https://blog.csdn.net/chenhongwu666/article/details/43524035" target="_blank" rel="noopener">CSDN的一个博客</a>说是服务器的问题，需要将服务器是否接受<code>utf-8</code>打开（看来命令行走的不是utf-8），结果结果改来改去还是这个问题！最后发现一个神贴：<a href="https://blog.csdn.net/iamsujin/article/details/19616247" target="_blank" rel="noopener">CSDN：python实现ftp中的乱码问题</a>。用更优雅的方法修改为<code>GB18030</code>就ok啦。之后又从<a href="http://www.jb51.net/article/88215.htm" target="_blank" rel="noopener">Python中的FTP通信模块ftplib的用法整理</a>学习了其他的操作，这是最后的代码，部分操作没有测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP</span><br><span class="line"></span><br><span class="line">ip = <span class="string">'101.200.57.174'</span></span><br><span class="line">user = <span class="string">'Anonymous'</span></span><br><span class="line">password = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file_name = '王王王.docx'</span></span><br><span class="line">file_name = <span class="string">'wang22ti.docx'</span></span><br><span class="line"></span><br><span class="line">ftp = FTP()</span><br><span class="line">ftp.set_pasv(<span class="keyword">False</span>)</span><br><span class="line">ftp.encoding = <span class="string">'GB18030'</span></span><br><span class="line">ftp.set_debuglevel(<span class="number">2</span>)</span><br><span class="line">ftp.connect(ip)</span><br><span class="line">ftp.login(user, password)</span><br><span class="line">print(ftp.getwelcome())</span><br><span class="line">ftp.storbinary(<span class="string">'STOR %s'</span> % file_name, open(file_name, <span class="string">'rb'</span>))</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'wang22ti_downloaded.docx'</span>, <span class="string">'wb'</span>)</span><br><span class="line">bufsize = <span class="number">1024</span></span><br><span class="line">ftp.retrbinary(<span class="string">'RETR %s'</span> % file_name, f.write, bufsize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ftp.cwd(pathname) #设置FTP当前操作的路径</span></span><br><span class="line"><span class="comment"># ftp.dir() #显示目录下文件信息</span></span><br><span class="line"><span class="comment"># file_list = ftp.nlst() #获取目录下的文件</span></span><br><span class="line"><span class="comment"># from pprint import pprint</span></span><br><span class="line"><span class="comment"># pprint(file_list)</span></span><br><span class="line"><span class="comment"># ftp.mkd(pathname) #新建远程目录</span></span><br><span class="line"><span class="comment"># ftp.pwd() #返回当前所在位置</span></span><br><span class="line"><span class="comment"># ftp.rmd(dirname) #删除远程目录</span></span><br><span class="line">ftp.delete(file_name) <span class="comment">#删除远程文件</span></span><br><span class="line"><span class="keyword">if</span> file_name <span class="keyword">not</span> <span class="keyword">in</span> ftp.nlst():</span><br><span class="line">    print(<span class="string">'delete OK - %s'</span> % file_name)</span><br><span class="line"><span class="comment"># ftp.rename(fromname, toname)#将fromname修改名称为toname。</span></span><br></pre></td></tr></table></figure><h1 id="1-3-对ftplib的进一步封装"><a href="#1-3-对ftplib的进一步封装" class="headerlink" title="1.3 对ftplib的进一步封装"></a>1.3 对ftplib的进一步封装</h1><p>可以说，ftplib已经比较方便了，但是一方面类似于<code>storbinary</code>和<code>retrbinary</code>一类的函数封装性仍然不够好，另一方面在实际使用中还会出现长时间无响应的情况。为了能够在作业中的体验更好，进一步封装ftplib如下：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嘉哥要做一个简单的云盘，所以就一步一步来吧。&lt;/p&gt;
&lt;h1 id=&quot;1-FTP&quot;&gt;&lt;a href=&quot;#1-FTP&quot; class=&quot;headerlink&quot; title=&quot;1 FTP&quot;&gt;&lt;/a&gt;1 FTP&lt;/h1&gt;&lt;p&gt;#1.1 FTP命令行上传下载&lt;/p&gt;
&lt;p&gt;嘉哥用阿里
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《计算机体系结构》实验2-MIPS指令集</title>
    <link href="http://wang22ti.com/2018/04/10/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E3%80%8B%E5%AE%9E%E9%AA%8C2-MIPS%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <id>http://wang22ti.com/2018/04/10/《计算机体系结构》实验2-MIPS指令集/</id>
    <published>2018-04-09T16:53:46.000Z</published>
    <updated>2018-04-11T14:34:40.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-lab1的内容"><a href="#0-lab1的内容" class="headerlink" title="0 lab1的内容"></a>0 lab1的内容</h1><h2 id="0-1-Exercise1"><a href="#0-1-Exercise1" class="headerlink" title="0.1  Exercise1"></a>0.1  Exercise1</h2><p>由下图易知LW R2,100(R3)对应的二进制代码为10001100011 00010 0000000001100100，转化为十六进制为0x8C62 0064。</p><p><img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image1.png" alt="">                              </p><p>由下图易知SW R5,100(R6)对应的二进制代码为10101100110 00101 000000001100100，转化为十六进制为0xACC5 0064。</p><p><img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image2.png" alt=""></p><h2 id="0-2-Exercise2"><a href="#0-2-Exercise2" class="headerlink" title="0.2  Exercise2"></a>0.2  Exercise2</h2><p>由下图易知OR R7,R18, R12对应的二进制代码为00000010010 01100 00111 00000 100101，转化为十六进制为0x024C 3825。</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image3.png" alt=""></p><p>由下图易知SUB R5,R4, R31对应的二进制代码为00000000100 11111 00101 00000 100010，转化为十六进制为0x009F 2822。</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image4.png" alt=""></p><h2 id="0-3-Exercise3"><a href="#0-3-Exercise3" class="headerlink" title="0.3  Exercise3"></a>0.3  Exercise3</h2><p>由下图易知BNEQ R7, R8,-5对应的二进制代码为00010100111 01000 11111111111111011，转化为十六进制为0x14E8 FFFB。当PC为124的时候，分支后的PC值为124 + (-5&lt;&lt;2) = 104。</p><p><img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image5.png" alt=""> </p><h2 id="0-4-Exercise5"><a href="#0-4-Exercise5" class="headerlink" title="0.4  Exercise5"></a>0.4  Exercise5</h2><p>不知道为啥没发现exercise4，但由下图易知ADDI R7, R8, 600对应的二进制代码为001000 01000 001110000001001011000，转化为十六进制为0x21070258。为啥没有SUBI呢？可能是因为该指令并不常用，且可以被ADDI代替，为了满足精简指令集的设计要求，就被去掉了。</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image6.png" alt=""></p><h1 id="1指令集学习"><a href="#1指令集学习" class="headerlink" title="1指令集学习"></a>1指令集学习</h1><p>​        因为我们班分配到的是分支指令（Branch），所以我遵循从简单到复杂的一般思路，学习了B和BAL两条指令，以及与他们相关的BEQ和BGEZAL两条指令。</p><h2 id="1-1-B和BEQ的学习"><a href="#1-1-B和BEQ的学习" class="headerlink" title="1.1 B和BEQ的学习"></a>1.1 B和BEQ的学习</h2><p>​        B指令在指令集说明里的介绍重点如下：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image7.png" alt=""></p><p>​        可见该32位的指令最高6位000100是用来告诉处理器——这是一条分支指令！而最低16位offset再加上2位的偏移量（之所以用2位是因为一条指令为32位即4位，4刚好是2的2次方）组成了一个±128Kb的相对寻址空间，用来指明指令相对寻址的位置。</p><p>​        那中间的两个00000呢？注意到该指令实际被机器翻译为BEQ r0, r0, offset，我又查看了BEQ指令，其重点介绍如下：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image8.png" alt=""></p><p>​        GPR看起来非常关键，我检索到如下信息：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image9.png" alt=""></p><p>​        Amazing！原来是通用寄存器的缩写，而且编号为0的通用寄存器的值永远为0。于是知道BEQ表示如果寄存器rs和寄存器rt的值如果相等就执行分支操作。进一步地，因为指令B的rs和rt均为编号为0的通用寄存器，所以就变成了无条件分支了！</p><h2 id="1-2-BAL和BGEZAL的学习"><a href="#1-2-BAL和BGEZAL的学习" class="headerlink" title="1.2 BAL和BGEZAL的学习"></a>1.2 BAL和BGEZAL的学习</h2><p>​        类似于1.1中的学习过程，我先查看了BAL的重点介绍：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image10.png" alt=""></p><p>​        指令BAL构造方式和指令B并不一样。但目前为止可以很容易理解的是，BAL执行的也是±128Kb范围内的相对寻址，和指令B不同的是BAL会把分支子程序运行结束、回到分支点后执行的下一条指令的地址（returnaddress link）存放在编号为31的通用寄存器里。它是怎么做到的呢？于是查看BGEZAL的重点介绍：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image11.png" alt=""></p><p>和1.1中的情况类似，指令BGEZAL是一个条件分支指令，当寄存器rs中的值大于等于0的情况下执行分支操作，而在指令BAL将寄存器rs强制为r0=0，于是就变成了无条件的分支。然而还有疑惑——如果10001表明这是一条BGEZAL指令，那么该指令最高6位的000001是什么意思呢？进一步检索到如下信息：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image12.png" alt=""></p><p>​        从这里可以明白REGIMM指明了immediate instruction的条件，看来opcode是一个很重要的信息！进一步检索，得到了更通用的信息——</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image13.png" alt=""></p><p>​        这幅图告诉我们，所有的MIPS指令都具有类似于6+5+5+16的形式，其中前6位被称为opcode——显然就是operation code！很顺利地，还找到了以下的几张表格——</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image14.png" alt=""></p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image15.png" alt=""></p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image16.png" alt=""></p><p>Unbelievable！将这几张图结合起来后，我们就可以明白计算机理解指令BAL的过程：</p><p>一、 读取opcode，发现是REGIMM，它表示要执行的指令是具有一个判断参数条件指令，参数用rs表示，而具体是什么指令呢？用rt表示。</p><p>二、 读取rt，发现是BGEZAL，它表示在rs≥0的情况下执行带有返回地址的分支操作，这已经是一条很具体的操作了。</p><p>三、 读取rs，发现是00000，于是就去读取编号为0的通用寄存器的值。而我们知道这个值恒为0，于是无条件地满足了分支条件。</p><p>四、 读取offset，对其做左移2位操作后执行分支操作。</p><p>五、 执行完分支程序，读取编号为31的通用寄存器里的返回地址并寻址执行。</p><h2 id="1-3-指令学习小结"><a href="#1-3-指令学习小结" class="headerlink" title="1.3 指令学习小结"></a>1.3 指令学习小结</h2><p>​        MIPS是经典的精简指令集，根据以上的学习，它使用了哪些技巧使得指令长度变短、数量减少呢？</p><p>一、 统一的指令格式。指令长度均为32位且为6+5+5+16的形式，一方面地址实现了对齐，指令中的地址就可以减少2位；另一方面降低了机器对指令理解的难度，必然可以提高一般任务下的执行效率。</p><p>二、 指令复用。B和BEQ、BAL和BGEZAL从机器码的角度来说是一模一样的，但是通过默认值的巧妙设定，用相同的机器码实现不同的指令，从而减少指令的总数。</p><p>三、 多级操作码。很多opcode仅仅表示一类指令，具体是哪一个指令需要进一步理解其他域中的值，因此opcode只需要6位即可。那为什么BEQ不采用这样的方式呢？显然是因为BEQ这一类指令需要更多的参数。</p><p>此外，本次实验中“顺藤摸瓜式”的搜索路径、“关键词查找”的搜索方法和类比的学习方法，让整个实验十分顺畅且严谨合理，也是值得总结回味的，它让我体会到一种探索的乐趣。</p><h1 id="2-大小端编址的实验测试"><a href="#2-大小端编址的实验测试" class="headerlink" title="2 大小端编址的实验测试"></a>2 大小端编址的实验测试</h1><p>根据实验要求，编写程序并运行如下：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image17.png" alt=""></p><p>可以看出，x1取的是x的低地址，输出的是0x1122的低地址对应的十进制数34，可见我的电脑的CPU（Intel 酷睿i7 7500U）采用的编址方式为小端编址。</p><h1 id="3观察指令执行过程——以winmips64为例"><a href="#3观察指令执行过程——以winmips64为例" class="headerlink" title="3观察指令执行过程——以winmips64为例"></a>3观察指令执行过程——以winmips64为例</h1><h2 id="3-1-观察指令执行过程——以计算阶乘为例"><a href="#3-1-观察指令执行过程——以计算阶乘为例" class="headerlink" title="3.1 观察指令执行过程——以计算阶乘为例"></a>3.1 观察指令执行过程——以计算阶乘为例</h2><p>​       虽然只知道这是一款MIPS指令集的仿真软件，参考文档糟糕的排版和字体让人提不起学习的兴趣，我还是打开了这款软件。由于此前的学习加上一些文献的查找，我觉得大体还是能看懂每个window的作用。它在我的眼里长这样：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image18.png" alt=""></p><p>然后我打开一段叫做factorial.s的程序，从字面上看这段程序是用来计算阶乘的：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image19.png" alt=""></p><p>​       实验要求为观察指令执行的过程，给出指令集和硬件高效执行关系的观察体会。于是我就开始一个周期一个周期地执行这个程序，直到第5个周期如下：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image20.png" alt=""></p><p>​       可以看出，指令采用五级流水线的方式执行，分为读指令、指令译码、指令执行、访问内存和写回寄存器五个阶段，每个阶段的时间均相同。同时，针对不同数据类型的指令，采用相应的硬件进行处理。</p><p>​       继续执行一个周期，发现statistics窗口多了一项数据：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image21.png" alt=""></p><p>恰好就是课上学的CPI！由于刚刚执行完一条指令，流水线的效果还没有显现，所以CPI = 5。继续执行几个周期，CPI逐渐减小并趋向于1，并要求我在终端（Terminal）输入计算阶乘的初值： </p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image22.png" alt=""></p><p>​       我输入了3后继续执行，出现了不一样的结果：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image23.png" alt=""></p><p>Amazing！可以看出，指令jal factorial让程序开始从003c读指令，而此前已经被读取、本应该在这个周期译码的、位于002c的指令daddi r24, r0, 1被阻塞了！于是Statistics窗口中Branch Taken Stall的值增加了1！再执行几个周期：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image24.png" alt=""></p><p>​        可以观察到流水线开始被重新构建。此外，结合参考手册中对于指令slti的介绍</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image25.png" alt=""></p><p>可知指令slti在对编号为10的寄存器进行写操作的同时指令bnez要对r10进行读操作，于是就产生了如图所示的“写后读”阻塞。进行执行若干个周期，上述两种情况交替出现若干次，目的在于将需要的数据即，n到1压入堆栈。运行若干周期之后终于跳出了这个循环，出现了新的情况：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image26.png" alt=""></p><p>​        Surprise！在执行指令dmulu的时候，使用了专门的硬件！同时由于乘法计算的时间仍然较长且与下一条指令dadd均需要访问编号为3的寄存器，所以整个程序都处于“写后读”阻塞！最终，当dmulu指令进入访问内存阶段时，statistics窗口中的Structural Stall的值变为了1！</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image27.png" alt=""></p><p>​        继续执行若干个周期，除了程序在循环计算阶乘的过程中又出现了StructuralStall外，并没有发现新的有趣的现象。最后，终端输出了正确的结果，statistics窗口中数据如下所示：</p><p> <img src="/2018/04/10/《计算机体系结构》实验2-MIPS指令集/image28.png" alt=""></p><p>​        最终的CPI为1.640，远远小于5，可见流水线的威力。</p><h2 id="3-2-指令观察小结"><a href="#3-2-指令观察小结" class="headerlink" title="3.2 指令观察小结"></a>3.2 指令观察小结</h2><p>​        这次仿真观察真是惊喜连连，我收获了哪些呢？</p><p>一、 流水线是一个复杂的系统，包括指令周期的划分、指令周期的对齐、资源冲突的应对等等，可以有效地减小CPI。</p><p>二、 为了对齐指令周期，需要尽量减少各个阶段的时间长度，例如通过指令长度的对齐和指令格式的统一提高译码效率。</p><p>三、 对了避免部分周期，尤其是执行周期流水线效率的影响，在设计指令集的时候就考虑使用不同的硬件以提高执行效率，例如采用协处理器专门处理浮点运算，采用专门的硬件计算加速乘法计算（这样的思想也被应用到近几年的异构计算中）。</p><h1 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h1><p>[1] MIPS指令集</p><p><a href="http://blog.sina.com.cn/s/blog_7f293c900100zdm8.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7f293c900100zdm8.html</a></p><p>[2] C++中数据类型int, short, long, long long的数据范围</p><p><a href="https://blog.csdn.net/elohims/article/details/23558779" target="_blank" rel="noopener">https://blog.csdn.net/elohims/article/details/23558779</a></p><p>[3] 大端模式和小端模式</p><p><a href="https://www.cnblogs.com/itcsl/p/6567963.html" target="_blank" rel="noopener">https://www.cnblogs.com/itcsl/p/6567963.html</a></p><p>[4] MIPS入门</p><p><a href="https://wenku.baidu.com/view/f719c320647d27284b735199.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/f719c320647d27284b735199.html</a></p><p>[5] MIPS的五级流水线</p><p><a href="http://imgtec.eetrend.com/article/1247" target="_blank" rel="noopener">http://imgtec.eetrend.com/article/1247</a></p><p>[6] MIPS指令集实验</p><p><a href="https://wenku.baidu.com/view/6d94c44c1fd9ad51f01dc281e53a580216fc509d.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/6d94c44c1fd9ad51f01dc281e53a580216fc509d.html</a></p><p>[7] cpu结构和功能</p><p><a href="https://max.book118.com/html/2017/0628/118707202.shtm" target="_blank" rel="noopener">https://max.book118.com/html/2017/0628/118707202.shtm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-lab1的内容&quot;&gt;&lt;a href=&quot;#0-lab1的内容&quot; class=&quot;headerlink&quot; title=&quot;0 lab1的内容&quot;&gt;&lt;/a&gt;0 lab1的内容&lt;/h1&gt;&lt;h2 id=&quot;0-1-Exercise1&quot;&gt;&lt;a href=&quot;#0-1-Exercise
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《操作系统》作业2.5-进程控制块的类C语言描述</title>
    <link href="http://wang22ti.com/2018/04/02/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E4%BD%9C%E4%B8%9A2-5-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E7%B1%BBC%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/"/>
    <id>http://wang22ti.com/2018/04/02/《操作系统》作业2-5-进程控制块的类C语言描述/</id>
    <published>2018-04-02T04:42:26.000Z</published>
    <updated>2018-04-02T04:48:09.312Z</updated>
    
    <content type="html"><![CDATA[<p>这个作业差点要手写，倒腾了一晚上，肯定还有很多问题，就先贴在这里吧。</p><p>2.5 试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对于过于复杂的功能或你无法解决的细节可采用指定功能的函数模块如处理机调度scheduler()来替代。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">pid_t</span> pid;<span class="comment">//进程pid</span></span><br><span class="line"><span class="keyword">pid_t</span> ppid;<span class="comment">//父进程pid</span></span><br><span class="line"> <span class="keyword">enum</span> status&#123;<span class="comment">//进程状态</span></span><br><span class="line"> CREATING,<span class="comment">//创建</span></span><br><span class="line"> TERMINATING,<span class="comment">//终止</span></span><br><span class="line"> RUNNING,<span class="comment">//执行</span></span><br><span class="line"> ACTIVE_READY,<span class="comment">//活动就绪</span></span><br><span class="line"> INACTIVE_READY,<span class="comment">//静止就绪</span></span><br><span class="line"> ACTIVE_BLOCK,<span class="comment">//活动阻塞</span></span><br><span class="line"> INACTIVE_BLOCK,<span class="comment">//静止阻塞</span></span><br><span class="line">&#125;;<span class="comment">//进程的状态</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> memory_address;<span class="comment">//进程下一次执行程序的开始地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allocate_address</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TO-DO: 为新的进程分配一块内存空间，返回首地址的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate_address</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TO-DO: 解除进程的内存分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> process(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> ppid) &#123;</span><br><span class="line"> <span class="keyword">this</span>.pid = pid;</span><br><span class="line"> <span class="keyword">this</span>.ppid = ppid;</span><br><span class="line"> <span class="keyword">this</span>.status = CREATING;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.pid != ERROR)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">this</span>.memory_address = allocate_address();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ~process()&#123;</span><br><span class="line"> <span class="keyword">this</span>.status = TERMINATING;</span><br><span class="line"> deallocate_address();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">pid_t</span> start_pid = <span class="number">0</span>;<span class="comment">//初始进程的pid</span></span><br><span class="line"><span class="keyword">pid_t</span> next_pid;<span class="comment">//下一个创建的的进程pid</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> <span class="title">running_porcess</span>;</span><span class="comment">//正在执行的进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">running_start_time</span>;</span><span class="comment">//正在执行进程开始执行的时间</span></span><br><span class="line"><span class="keyword">long</span> max_time = <span class="number">100</span>;<span class="comment">//一个时间片的长度（微秒）</span></span><br><span class="line"><span class="built_in">queue</span>&lt;struct process&gt; ready_queue;<span class="comment">//就绪进程的队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;struct process&gt; block_queue;<span class="comment">//阻塞进程的队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;struct process&gt; suspend_queue;<span class="comment">//挂起进程的的队列</span></span><br><span class="line"><span class="keyword">int</span> genearl_register[<span class="number">4</span>][<span class="number">2</span>];<span class="comment">//标准寄存器</span></span><br><span class="line"><span class="keyword">int</span> PSW[<span class="number">16</span>];<span class="comment">//状态寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> system&#123;<span class="comment">//状态转移</span></span><br><span class="line"> CREATE,<span class="comment">//创建</span></span><br><span class="line"> BLOCK,<span class="comment">//阻塞</span></span><br><span class="line"> RELEASE,<span class="comment">//释放</span></span><br><span class="line"> SUSPEND,<span class="comment">//挂起</span></span><br><span class="line"> ACTIVATE,<span class="comment">//激活</span></span><br><span class="line"> TERMINATE,<span class="comment">//终止</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; operater_queue;<span class="comment">//待执行的操作的队列</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct process <span class="title">create</span><span class="params">(<span class="keyword">pid_t</span> ppid)</span></span>;<span class="comment">//创建进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block</span><span class="params">()</span></span>;<span class="comment">//阻塞正在执行的进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(struct process)</span></span>;<span class="comment">//释放阻塞的进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suspend</span><span class="params">(struct process)</span></span>;<span class="comment">//挂起进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activate</span><span class="params">(struct process)</span></span>;<span class="comment">//激活被挂起的进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminate</span><span class="params">(struct process)</span></span>;<span class="comment">//终止进程</span></span><br><span class="line"></span><br><span class="line">system();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> <span class="title">system</span>:</span>:create(<span class="keyword">pid_t</span> ppid) &#123;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">new_process = process(<span class="keyword">this</span>.next_pid , ppid);</span><br><span class="line"><span class="keyword">this</span>.next_pid += <span class="number">1</span>;</span><br><span class="line">new_process.status = ACTIVE_READY;</span><br><span class="line"><span class="keyword">this</span>.ready_queue.push(new_process);</span><br><span class="line"><span class="keyword">this</span>.timeval = gettiemofday();</span><br><span class="line"><span class="keyword">return</span> new_process;</span><br><span class="line"><span class="keyword">catch</span>:</span><br><span class="line"><span class="keyword">return</span> process(ERROR, ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> system::block() &#123;</span><br><span class="line"><span class="keyword">this</span>.running_porcess.memory_address = getNowAddress();</span><br><span class="line"><span class="comment">// 阻塞执行进程，调度下一个进程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.running_porcess != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.running_porcess.status = ACTIVE_BLOCK;</span><br><span class="line">block_queue.push(<span class="keyword">this</span>.running_porcess);</span><br><span class="line"><span class="keyword">this</span>.running_porcess = <span class="keyword">this</span>.ready_queue.pop():</span><br><span class="line">&#125;</span><br><span class="line">scheduler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> system::release(struct process) &#123;</span><br><span class="line"><span class="comment">// 释放活动阻塞进程，转入活动就绪</span></span><br><span class="line"><span class="keyword">if</span> (process.status == ACTIVE_BLOCK)</span><br><span class="line">&#123;</span><br><span class="line">process.status = ACTIVE_READY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放静止阻塞进程，转入静止就绪</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (process.status == INACTIVE_BLOCK)</span><br><span class="line">&#123;</span><br><span class="line">process.status == INACTIVE_READY;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ready_queue.push(process);</span><br><span class="line">block_queue.pop(process);</span><br><span class="line">scheduler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> system::suspend(struct process) &#123;</span><br><span class="line">porcess.memory_address = getNowAddress();</span><br><span class="line"><span class="comment">// 挂起执行进程，转入静止就绪，调度下一个程序</span></span><br><span class="line"><span class="keyword">if</span> (process == <span class="keyword">this</span>.running_porcess) &#123;</span><br><span class="line">process.status = INACTIVE_READY;</span><br><span class="line">next_process = ready_queue.pop();</span><br><span class="line"><span class="keyword">if</span> (! suspend_queue.isMember(new_process))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.running_porcess = new_process;</span><br><span class="line">exec_from(new_process.memory_address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂起活动就绪进程，转入静止就绪</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ready_queue.isMember(process))</span><br><span class="line">&#123;</span><br><span class="line">process.status = INACTIVE_READY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂起活动阻塞进程，转入静止阻塞</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (block_queue.isMember(process)) &#123;</span><br><span class="line">process.status = INACTIVE_BLOCK;</span><br><span class="line">&#125;</span><br><span class="line">suspend_queue.push(process);</span><br><span class="line">scheduler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> system::activate(struct process) &#123;</span><br><span class="line"><span class="comment">// 如果是就绪进程，转入活动就绪</span></span><br><span class="line"><span class="keyword">if</span> (ready_queue.isMember(process))</span><br><span class="line">&#123;</span><br><span class="line">process.status == ACTIVE_READY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是阻塞进程，转入活动阻塞</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (block_queue.isMember(process))</span><br><span class="line">&#123;</span><br><span class="line">process.status == ACTIVE_BLOCK;</span><br><span class="line">&#125;</span><br><span class="line">suspend_queue.pop(process);</span><br><span class="line">scheduler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> system::terminate(struct process) &#123;</span><br><span class="line"><span class="comment">// 调用该进程的析构函数，并调度下一个进程</span></span><br><span class="line">process.~process();</span><br><span class="line"><span class="keyword">this</span>.next_process = ready_queue.pop();</span><br><span class="line"><span class="keyword">if</span> (! suspend_queue.isMember(new_process))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.running_porcess = new_process;</span><br><span class="line">exec_from(new_process.memory_address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system::system() &#123;</span><br><span class="line"><span class="keyword">this</span>.next_pid = <span class="keyword">this</span>.start_pid;</span><br><span class="line">ready_queue = <span class="built_in">queue</span>&lt;struct process&gt;();</span><br><span class="line">block_queue = <span class="built_in">queue</span>&lt;struct process&gt;();</span><br><span class="line">suspend_queue = <span class="built_in">queue</span>&lt;struct process&gt;();</span><br><span class="line"><span class="comment">//初始化状态转移队列，并将系统启动时必要的一些状态转移入列</span></span><br><span class="line">operater_queue = <span class="built_in">queue</span>&lt;strct process&gt;(<span class="comment">/*TO-DO: 一些状态转移*/</span>);</span><br><span class="line"><span class="comment">// 创建第一个进程</span></span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">this</span>.running_porcess = <span class="keyword">this</span>.create(<span class="keyword">this</span>.start_pid).pid != ERROR);</span><br><span class="line"><span class="keyword">this</span>.timeval = gettiemofday();</span><br><span class="line"><span class="keyword">this</span>.running_porcess.status = RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 选择下一个状态转移</span></span><br><span class="line"><span class="keyword">if</span> ( !operater_queue.isEmpty() )</span><br><span class="line">&#123;</span><br><span class="line">operater = operater_queue.pop();</span><br><span class="line"><span class="keyword">switch</span> operater &#123;</span><br><span class="line">CREATE: <span class="keyword">this</span>.create(<span class="keyword">this</span>.running_porcess.pid);<span class="keyword">break</span>;</span><br><span class="line">BLOCK: <span class="keyword">this</span>.block();<span class="keyword">break</span>;</span><br><span class="line">RELEASE: <span class="keyword">this</span>.release();<span class="keyword">break</span>;</span><br><span class="line">SUSPEND: <span class="keyword">this</span>.suspend(process);<span class="keyword">break</span>;</span><br><span class="line">ACTIVATE: <span class="keyword">this</span>.activate();<span class="keyword">break</span>;</span><br><span class="line">TERMINATE: <span class="keyword">this</span>.terminate();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间片结束，当前进程转移到活动就绪，并调度下一个进程</span></span><br><span class="line"><span class="keyword">if</span> (gettiemofday - <span class="keyword">this</span>.timeval &gt;= <span class="keyword">this</span>.max_time <span class="keyword">or</span> <span class="keyword">this</span>.running_porcess == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.running_porcess.memory_address = getNowAddress();</span><br><span class="line"><span class="keyword">this</span>.running_porcess.status = ACTIVE_READY;</span><br><span class="line">ready_queue.push(<span class="keyword">this</span>.running_porcess);</span><br><span class="line">next_process = ready_queue.pop();</span><br><span class="line"><span class="keyword">if</span> (! suspend_queue.isMember(new_process))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.running_porcess = new_process;</span><br><span class="line">exec_from(new_process.memory_address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个作业差点要手写，倒腾了一晚上，肯定还有很多问题，就先贴在这里吧。&lt;/p&gt;
&lt;p&gt;2.5 试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>每天都写点算法18-4</title>
    <link href="http://wang22ti.com/2018/04/02/%E6%AF%8F%E5%A4%A9%E9%83%BD%E5%86%99%E7%82%B9%E7%AE%97%E6%B3%9518-4/"/>
    <id>http://wang22ti.com/2018/04/02/每天都写点算法18-4/</id>
    <published>2018-04-02T04:39:16.000Z</published>
    <updated>2018-04-20T13:59:32.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="18-4-20"><a href="#18-4-20" class="headerlink" title="18-4-20"></a>18-4-20</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定平面上n个点，找其中一对点，使得在n个点组成的所有点对中，该点对间的距离最小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LessSort</span><span class="params">(point a, point b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)  </span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;  </span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inf = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">nearestPointPair</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt; &amp;points, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right &lt;= left) &#123;</span><br><span class="line"><span class="keyword">return</span> inf;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(right - left == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> distance(points[left], points[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> left_min = nearestPointPair(points, left, center);</span><br><span class="line"><span class="keyword">double</span> right_min = nearestPointPair(points, center, right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = min(left_min, right_min);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> center_min = inf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left_ = center - <span class="number">1</span>; left_ &gt;= left &amp;&amp; points[center].x - points[left_].x &lt; d; left_--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> right_ = center + <span class="number">1</span>; right_ &lt;= right &amp;&amp; points[right_].x - points[center].x &lt; d; right_++) &#123;</span><br><span class="line">center_min = min(center_min, distance(points[left_], points[right_]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> min(center_min, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; points;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_points;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num_points;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i)</span><br><span class="line">&#123;</span><br><span class="line">point p;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">points.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(points.begin(), points.end(), LessSort);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> distance = nearestPointPair(points, <span class="number">0</span>, points.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; distance &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">100 100</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="18-4-11-19"><a href="#18-4-11-19" class="headerlink" title="18-4-11-19"></a>18-4-11-19</h1><p><a href="http://wang22ti.com/2018/04/20/%E5%8C%97%E4%BA%AC%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88%E9%87%8D%E7%8E%B0%E8%B5%9B%EF%BC%89/">参见另外一篇博客</a></p><p>#18-4-10</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;T&gt; <span class="title">quickSort</span>(<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (v.size() &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; anchor = &#123;v[<span class="number">0</span>], &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1 = <span class="built_in">vector</span>&lt;T&gt;();</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2 = <span class="built_in">vector</span>&lt;T&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::iterator i = v.begin() + <span class="number">1</span>; i != v.end(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*i == v[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">anchor.push_back(*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*i &gt; v[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*i &lt; v[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1_sorted = quickSort(v1);</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2_sorted = quickSort(v2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_ret = <span class="built_in">vector</span>&lt;T&gt;();</span><br><span class="line">v_ret.insert(v_ret.end(), v1_sorted.begin(), v1_sorted.end());</span><br><span class="line">v_ret.insert(v_ret.end(), anchor.begin(), anchor.end());</span><br><span class="line">v_ret.insert(v_ret.end(), v2_sorted.begin(), v2_sorted.end());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> v_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">72</span>, <span class="number">45</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = quickSort(v3);</span><br><span class="line">copy (v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt; (<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-4-6"><a href="#18-4-6" class="headerlink" title="18-4-6"></a>18-4-6</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题描述：设A[1, 2, ..., n]的是一个包含个n不同非负整数的数组。</span></span><br><span class="line"><span class="comment">// 如果在i&lt;j的情况下，有，A[i]&gt;A[j]，则(A[i]，、A[j])就称为A中的一个逆序对。</span></span><br><span class="line"><span class="comment">// 例如，数组（3，1，4，5，2）的“逆序对”有&lt;3，1&gt;、&lt;3，2&gt;、&lt;4，2&gt;、&lt;5，2&gt;共4个。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数列中的许多问题貌似都需要先排序</span></span><br><span class="line"><span class="comment">// 在归并排序的基础上稍加修改即可，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;T&gt; <span class="title">merge</span>(<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v1</span>, <span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v2</span>, <span class="title">int</span> *<span class="title">num</span>) &#123;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v = <span class="built_in">vector</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::iterator i = v1.begin();</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::iterator j = v2.begin();</span><br><span class="line"><span class="comment">// end()指向的是最后一个元素的后一个位置</span></span><br><span class="line"><span class="keyword">while</span> (i != v1.end() &amp;&amp; j != v2.end()) &#123;</span><br><span class="line"><span class="keyword">if</span> (*i &lt;= *j) &#123;</span><br><span class="line">v.push_back(*i);</span><br><span class="line">*num += (j - v2.begin());</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v.push_back(*j);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == v1.end()) &#123;</span><br><span class="line">v.insert(v.end(), j, v2.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v.insert(v.end(), i, v1.end());</span><br><span class="line"><span class="comment">// 将迭代器转换为索引值</span></span><br><span class="line">*num += (v1.end() - i) * v2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;T&gt; <span class="title">mergeSort</span>(<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v</span>, <span class="title">int</span>* <span class="title">num</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (v.size() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; v[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v.size() == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] &gt; v[<span class="number">1</span>]) &#123;</span><br><span class="line">T temp =  v[<span class="number">0</span>];</span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">1</span>];</span><br><span class="line">v[<span class="number">1</span>] = temp;</span><br><span class="line">(*num)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> center = v.size() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_left(v.begin(), v.begin() + center);</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_right(v.begin() + center, v.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_l = mergeSort(v_left, num);</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_r = mergeSort(v_right, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> merge(v_l, v_r, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// vector&lt;int&gt; v1 = &#123;3, 1, 4, 5, 2&#125;;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意指针的初始化方法</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p_num = &amp;num;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = mergeSort(v1, p_num);</span><br><span class="line">copy (v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt; (<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-4-5"><a href="#18-4-5" class="headerlink" title="18-4-5"></a>18-4-5</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个模板函数之前都需要声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;T&gt; <span class="title">merge</span>(<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v1</span>, <span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v2</span>) &#123;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v = <span class="built_in">vector</span>&lt;T&gt;();</span><br><span class="line"><span class="comment">// 模板迭代器需要在前面加上typename</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::iterator i = v1.begin();</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::iterator j = v2.begin();</span><br><span class="line"><span class="keyword">while</span> (i != v1.end() &amp;&amp; j != v2.end()) &#123;</span><br><span class="line"><span class="keyword">if</span> (*i &lt;= *j) &#123;</span><br><span class="line">v.push_back(*i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v.push_back(*j);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == v1.end()) &#123;</span><br><span class="line"><span class="comment">// 在v.end()处插入v2从j到v2.end()处的值，闭区间</span></span><br><span class="line">v.insert(v.end(), j, v2.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v.insert(v.end(), i, v1.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;T&gt; <span class="title">mergeSort</span>(<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">v</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (v.size() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v.size() == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] &gt; v[<span class="number">1</span>]) &#123;</span><br><span class="line">T temp =  v[<span class="number">0</span>];</span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">1</span>];</span><br><span class="line">v[<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> center = v.size() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开区间</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_left(v.begin(), v.begin() + center);</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_right(v.begin() + center, v.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_l = mergeSort(v_left);</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v_r = mergeSort(v_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> merge(v_l, v_r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = merge(v1, v2);</span><br><span class="line">copy (v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt; (<span class="built_in">cout</span>, <span class="string">" "</span>)); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">72</span>, <span class="number">45</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">v = mergeSort(v3);</span><br><span class="line">    <span class="comment">// 记住这种打印容器的方式</span></span><br><span class="line">copy (v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt; (<span class="built_in">cout</span>, <span class="string">" "</span>)); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定正整数n和m，</span></span><br><span class="line"><span class="comment">// 计算出n个元素的集合&#123;1,2,…,n &#125;可以划分为多少个不同的由m个非空子集构成的集合。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算类的递归问题，重点在于写递推公式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Striling</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( n == m || m == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &lt; m || m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m * Striling(n - <span class="number">1</span>, m) + Striling(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Striling(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-4-4"><a href="#18-4-4" class="headerlink" title="18-4-4"></a>18-4-4</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阶乘和斐波拉契的递归解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; factorial(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fibonacci(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-4-3"><a href="#18-4-3" class="headerlink" title="18-4-3"></a>18-4-3</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定长度为n的单调不下降数列𝑎0,⋯,𝑎(𝑛−1) 和一个数𝑘，求满足条件𝑎𝑖≥𝑘的最小值𝑖，不存在的情况下输出n。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于有序数据当然使用二分法，</span></span><br><span class="line"><span class="comment">// 因为求最小值，转换为求k大于的数的最大下标+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minBiggerInSortedSequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = v.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注意二分法结束条件的判断</span></span><br><span class="line"><span class="keyword">while</span> (left + <span class="number">1</span> != right) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; v[center]) &#123;</span><br><span class="line">left = center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">right = center;</span><br><span class="line">&#125;</span><br><span class="line">center = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 注意每轮结束out的赋值</span></span><br><span class="line">out = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minBiggerInSortedSequence(v, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-4-2"><a href="#18-4-2" class="headerlink" title="18-4-2"></a>18-4-2</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个很长的数字串S：123456891011121314…，</span></span><br><span class="line"><span class="comment">// 它是由所有的自然数从小到大依次排列起来的。</span></span><br><span class="line"><span class="comment">// 任意给一个数字串S1(其长度不大于10)，求出S1在S中第一次出现的位置。</span></span><br><span class="line"><span class="comment">// 比如：输入101，输出为10。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// string::substr(i, n)表示从i开始的、长度为n的子串</span></span><br><span class="line"><span class="comment">// 将string转为int需要先通过string::c_str()将其转换为C语言字符串，再使用atoi()函数</span></span><br><span class="line"><span class="comment">// string::to_string()可以将数字类型的变量转为string</span></span><br><span class="line"><span class="comment">// 要注意返回值类型与定义类型相同，不能留下python后遗症</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstSubstrInNumstr</span><span class="params">(<span class="built_in">string</span> S1)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 按照匹配位数枚举</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= S1.length(); ++len) &#123;</span><br><span class="line"><span class="comment">// 按照前缀长度枚举</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> first_len = <span class="number">1</span>; first_len &lt;= len; ++first_len) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断前缀</span></span><br><span class="line"><span class="built_in">string</span> before = S1.substr(<span class="number">0</span>, first_len);</span><br><span class="line"><span class="built_in">string</span> after = S1.substr(first_len, len);</span><br><span class="line"><span class="keyword">int</span> n_before = atoi(before.c_str());</span><br><span class="line"><span class="keyword">int</span> n_after = atoi(after.c_str()) % <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">10</span>, first_len));</span><br><span class="line"><span class="keyword">int</span> out = atoi(after.c_str()) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((n_before + <span class="number">1</span>) % <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">10</span>, first_len)) != n_after) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断中部</span></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>, before = after; first_len + len * ( k + <span class="number">1</span>) - <span class="number">1</span> &lt; S1.length(); ++k, before = after) &#123;</span><br><span class="line">after = S1.substr(first_len + len * k, len);</span><br><span class="line">n_before = atoi(before.c_str());</span><br><span class="line">n_after = atoi(after.c_str());</span><br><span class="line"><span class="keyword">if</span> (n_before + <span class="number">1</span> != n_after) &#123;</span><br><span class="line">tag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tag == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断后缀</span></span><br><span class="line">before = to_string(<span class="keyword">int</span>(atoi(after.c_str()) + <span class="number">1</span>));</span><br><span class="line">after = S1.substr(first_len + len * k);</span><br><span class="line"><span class="keyword">if</span> (before.substr(<span class="number">0</span>, after.length()) != after) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 均不匹配，返回S1对应的int</span></span><br><span class="line"><span class="keyword">return</span> atoi(S1.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"910111213"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; FirstSubstrInNumstr(s1) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-4-1"><a href="#18-4-1" class="headerlink" title="18-4-1"></a>18-4-1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Narcissus数则特指一个n位数中各数字的n次幂之和等于自身的数。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力枚举的关键在于选定枚举的角度</span></span><br><span class="line"><span class="comment">// 对于等式而言，就是选择左边还右边，还可以通过移项减少复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNarcissus1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i * <span class="number">100</span> + j * <span class="number">10</span> + k == <span class="built_in">pow</span>(i, <span class="number">3</span>) + <span class="built_in">pow</span>(j, <span class="number">3</span>) + <span class="built_in">pow</span>(k, <span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i * <span class="number">100</span> + j * <span class="number">10</span> + k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNarcissus2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">pow</span>(<span class="number">10</span>, n - <span class="number">1</span>); i &lt; <span class="built_in">pow</span>(<span class="number">10</span>, n); ++i)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> num = i;</span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line"> &#123;</span><br><span class="line"> sum += <span class="built_in">pow</span>(num % <span class="number">10</span>, n);</span><br><span class="line"> num /= <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (sum == i)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printNarcissus1();</span><br><span class="line">printNarcissus2(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我国古代数学家张丘建在《算经》中出了一道题</span></span><br><span class="line"><span class="comment">// “鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？”，</span></span><br><span class="line"><span class="comment">// 现在假定各鸡种的价格不变，拥有的钱数为m，需要购买的鸡数为n，试求出所有可能的购买方案总数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mMoneynChicken</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num_plan = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num_rooster = <span class="number">0</span>; num_rooster &lt;= m / <span class="number">5</span>; ++num_rooster)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num_hen = <span class="number">0</span>; num_hen &lt;= (m - <span class="number">5</span> * num_rooster) / <span class="number">3</span>; ++num_hen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> money_chick = <span class="number">0</span>; ; ++money_chick)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">5</span> * num_rooster + <span class="number">3</span> * num_hen + money_chick) &#123;</span><br><span class="line"><span class="keyword">if</span> (num_rooster + num_hen + money_chick * <span class="number">3</span> == n) &#123;</span><br><span class="line">num_plan += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num_plan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mMoneynChicken(<span class="number">10</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-3-31"><a href="#18-3-31" class="headerlink" title="18-3-31"></a>18-3-31</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试求解输入数组的连续子序列和的最大值。如果所有的整数都是负数，那么最大连续子数列和为0。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三重循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubSum1</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                thisSum += a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (thisSum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二重循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubSum2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.size(); ++j) &#123;</span><br><span class="line">            thisSum += a[j];</span><br><span class="line">            <span class="keyword">if</span> (thisSum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一重循环，最优</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubSum3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>, nowSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">        nowSum += a[i];</span><br><span class="line"><span class="comment">//      抛弃小于0的前缀</span></span><br><span class="line">        <span class="keyword">if</span> (nowSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nowSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nowSum &gt; maxSum) &#123;</span><br><span class="line">            maxSum = nowSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubSumRec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先讨论非递归情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[left] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLeftSum = maxSubSumRec(a, left, center);</span><br><span class="line">    <span class="keyword">int</span> maxRightSum = maxSubSumRec(a, center + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nowRightBorderSum = <span class="number">0</span>, maxRightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 精髓在于认识到关键词不仅在于最大，还在于连续</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = center + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">        nowRightBorderSum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (nowRightBorderSum &gt; maxRightBorderSum) &#123;</span><br><span class="line">            maxRightBorderSum = nowRightBorderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nowLeftBorderSum = <span class="number">0</span>, maxLeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = center; j &gt;= left; --j) &#123;</span><br><span class="line">        nowLeftBorderSum += a[j];</span><br><span class="line">        <span class="keyword">if</span> (nowLeftBorderSum &gt; maxLeftBorderSum) &#123;</span><br><span class="line">            maxLeftBorderSum = nowLeftBorderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(maxRightBorderSum + maxLeftBorderSum, max(maxLeftSum, maxRightSum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">-2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">-1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSubSum1(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSubSum2(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSubSum3(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSubSumRec(a, <span class="number">0</span>, a.size()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;18-4-20&quot;&gt;&lt;a href=&quot;#18-4-20&quot; class=&quot;headerlink&quot; title=&quot;18-4-20&quot;&gt;&lt;/a&gt;18-4-20&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日记18-4</title>
    <link href="http://wang22ti.com/2018/04/01/%E6%97%A5%E8%AE%B018-4/"/>
    <id>http://wang22ti.com/2018/04/01/日记18-4/</id>
    <published>2018-04-01T13:23:32.000Z</published>
    <updated>2018-04-20T13:54:51.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="18-4-20"><a href="#18-4-20" class="headerlink" title="18-4-20"></a>18-4-20</h1><p>上午上完系统结构和萌主讨论了编译原理，</p><p>下午终于把生产者消费者进程同步搞定了！！开心！！</p><p>回来把数学建模以及软件设计比赛报了名，</p><p>晚上写了最近点问题，之后向优秀的郝静宇同学请教超时的两道题目。</p><h1 id="18-4-19"><a href="#18-4-19" class="headerlink" title="18-4-19"></a>18-4-19</h1><p>下午竟然睡到了4点多，几乎一天就过去了。。</p><p>之后和嘉哥、时清、翔哥讨论了云计算作业的细节。</p><p>晚上用MIPS指令写了冒泡排序，最后一分钟提交上去，刺激。</p><h1 id="18-4-18"><a href="#18-4-18" class="headerlink" title="18-4-18"></a>18-4-18</h1><p>上午和体系结构董老师申请了补做冒泡排序，一节课都在统计信息。</p><p>云计算课上进一步学习了ftplib包，这个包不错，但是可以进一步封装。</p><p>于是和嘉哥讨论了一下软件的架构，明天具体讨论一下接口。</p><p>晚上和浩珉健身，之后开了学习部的例会。</p><p>回来几乎没有学习，只是把操作系统实验第二题完成了。</p><h1 id="18-4-17"><a href="#18-4-17" class="headerlink" title="18-4-17"></a>18-4-17</h1><p>上午终于把软件工程作业交了。。</p><p>又优化了一点词法分析器。</p><p>一觉醒来得知创青春得了三等奖，美滋滋。</p><p>之后几乎一直都在写操作系统的实验，emmmm，说明文档写得太差了。</p><h1 id="18-4-16"><a href="#18-4-16" class="headerlink" title="18-4-16"></a>18-4-16</h1><p>一早起来交了朋辈辅导师的报名表，</p><p>之后疯狂操作操作系统作业。。</p><p>中午和子芃、文婷开了会，主要讨论协作方案。</p><p>下午一个半小时又写了2道校赛acm，考虑到没有签到题，可以认为速度有所提高。</p><p>但是晚上写了2道都超时了。。看来还需要基础算法的加强。。</p><h1 id="18-4-15"><a href="#18-4-15" class="headerlink" title="18-4-15"></a>18-4-15</h1><p>早上起来把Ubuntu的远程桌面搞定了，这下真的可以当做服务器来使了。</p><p>结果出门忘了再设置一下，GG</p><p>报名了朋辈辅导师。</p><p>下午去团支部评定的现场溜达一下，</p><p>其他就一直在做acm校赛的热身赛，</p><p>3三小时4道，前3道1小时，</p><p>第一次过oj，刺激。</p><p>和子芃、文婷组队参加数学建模校赛。</p><p>吃完饭把软工作业写了，</p><p>真是的，连题目都没讲清楚。。</p><p>临睡得知被学院提名为学代会委员了，填了份提名表。</p><h1 id="18-4-14"><a href="#18-4-14" class="headerlink" title="18-4-14"></a>18-4-14</h1><p>上午大概看了操作系统的实验，啊都要自学。</p><p>下午直到晚上反复打磨编译原理的词法分析程序，终于有了一个比较满意的程序，学到了不少</p><p>末了把学代会的名单报了上去。</p><h1 id="18-4-13"><a href="#18-4-13" class="headerlink" title="18-4-13"></a>18-4-13</h1><p>上午写了ftp的博文，搞定了中文路径出错的问题。</p><p>2点和袁锐去看五四奖章的答辩，伏地膜</p><p>之后的时间把编译第三章作业完成了，画图到恶心，不过还是有些收获。</p><p>#18-4-12</p><p>在徐老师的监督下，40分钟写了第一次实验，第一轮用C++根本完不成，用python还是搞定了</p><p>下午起来和任老师讨论了项目，还是要抓紧了。</p><p>之后和嘉哥、时清、翔哥讨论了云计算的作业，学了ftp的命令行和python调用。</p><p>晚上去看党支部组织的《厉害了，我的国》。</p><p>讲道理，几乎都是纪录片的剪辑，配音配乐并不出色。</p><p>但是南仁东老先生的生前最后一次采访，真是让人有一种撕心裂肺的的感动，国士无双。</p><p>回来和袁锐自习，处理一些杂项。</p><p>又没有写算法。。这不行</p><h1 id="18-4-11"><a href="#18-4-11" class="headerlink" title="18-4-11"></a>18-4-11</h1><p>上午上完两节课就去开学代会的布置会，</p><p>回来倒头就睡，醒来已经是3点45了。</p><p>班级出人填文件还是很困难，心态复杂，忽然感到阵阵孤独感。</p><p>晚上开了学生会的例会，做了编译原理第三章作业部分。</p><p>原来准备把最近点问题写好的，</p><p>但是里面涉及很多忘了的C++知识，明天再干吧。</p><h1 id="18-4-10"><a href="#18-4-10" class="headerlink" title="18-4-10"></a>18-4-10</h1><p>上午上完编译，20分钟把快速排序写好了，看来分治算法初步掌握了。</p><p>中午把团日活动案例和总结交了，班级的事情暂时告一段落了。</p><p>下午写了软件工程的作业，真是难受。。</p><p>晚上开了党支部的述职会议。</p><h1 id="18-4-9"><a href="#18-4-9" class="headerlink" title="18-4-9"></a>18-4-9</h1><p>中午去开了一个班长支书的临时会议，又多了点事情。。</p><p>姗哥做的推送蛮好哒，虽然她觉得排版有问题，但是最后还是有177和13的阅读量和赞呀！</p><p>下午写好了体系结构的作业！十分高质量的。</p><p>晚上彻底搞定了团日活动的案例和总结，</p><p>还有修改了英才奖的申请表。</p><p>看来周六去吃鱼肉火锅是正确的！</p><h1 id="18-4-8"><a href="#18-4-8" class="headerlink" title="18-4-8"></a>18-4-8</h1><p>翔哥一大早又去了医院，啊，上午困得要死。。课上睡着了。。</p><p>之后在1706班做党支部的述职。</p><p>下午睡醒后好多啦！一顿疯狂操作，搞定了支部等级评估、活动案例和活动总结，班级这波事情基本算是结束啦！</p><p>语音输入真是神器！</p><p>本来想把软件工程的作业写好的，然而实在恶心，于是把体系结构的作业写了一半，对MIPS有了初步的理解。</p><p>晚上给同学们分翔哥送我的草莓，蛮好吃的~</p><p>今天真的早睡啦，晚安。</p><p>但是又没有写算法！！！</p><h1 id="18-4-7"><a href="#18-4-7" class="headerlink" title="18-4-7"></a>18-4-7</h1><p>一早被翔哥喊醒，带他去校医院、北京大学附属人民医院、清华大学第二附属医院去看尿结石。。</p><p>匆匆赶到学校，吃了外卖就开班会</p><p>开完班会和大家一起去新中关看《头号玩家》，</p><p>虽然由于玩的游戏不多导致看不懂许多梗吧，但是CG特效真的特别棒！</p><p>本来因为感觉姗哥闷闷不乐留下来，</p><p>结果和袁锐去吃鱼肉火锅啊哈哈。</p><p>好久没有慢悠悠地涮火锅了啊。。</p><p>回来骑ofo，mmd，坏了4辆，骑上的巨沉，几乎可以当做健身了。。</p><p>没有写文件、没有写代码、没有操任何社团的心，</p><p>真是生活的一天啊。。</p><p>这样的日子，多一点好还是少一点好呢？</p><h1 id="18-4-6"><a href="#18-4-6" class="headerlink" title="18-4-6"></a>18-4-6</h1><p>写了个逆序对的题，</p><p>其他时间主要在做班会PPT。。</p><p>学习不能耽误了。</p><p>老妈喝醉了，但是肺腑之言却让我很感动。</p><h1 id="18-4-5"><a href="#18-4-5" class="headerlink" title="18-4-5"></a>18-4-5</h1><p>啊，吃晚饭之前都在玩，可以说是很悠闲了。</p><p>下午睡觉，很有精神，就写了归并排序，</p><p>重点重温了模板，C++水平已经超越巅峰值。</p><p>之后打羽毛球，好久没锻炼了。。</p><p>末了梳理了一下班级和党支部的事务。</p><h1 id="18-4-4"><a href="#18-4-4" class="headerlink" title="18-4-4"></a>18-4-4</h1><p>妈耶，大雪纷飞。</p><p>上了三节课，浑浑噩噩睡到3点，白天就过去了，不开心。</p><p>晚上处理了班级、党支部的一些事情，填好了英才奖的申请表。</p><p>时清给我的钱没及时给老妈，买了电影票又不够给大哥，于是从老妈那里空手套白狼一波，嘿嘿</p><p>之后玩了一会《守望先锋》</p><h1 id="18-4-3"><a href="#18-4-3" class="headerlink" title="18-4-3"></a>18-4-3</h1><p>下午开了班级负责人的会</p><p>团日活动、支部等级评定、团员评优、党员述职、看电影……</p><p>一大堆事情一下子铺开了。</p><p>大创估计就是校级了，有点忧伤，但没事！这算什么</p><p>晚上接到李老师关于英才奖的通知，希望好结果。</p><p>末了写了MIUI俱乐部的帖子。</p><h1 id="18-4-2"><a href="#18-4-2" class="headerlink" title="18-4-2"></a>18-4-2</h1><p>论文的进度变为预审了，清明把另一篇写好吧。</p><p>上午终于把时清手机的事情处理了，啊，貌似没听课，GG。</p><p>中午开班长支书会，关于支部评定。。</p><p>晚上开了党支部学习会，补了一些材料。。</p><p>其余的时间好不容易写了一题acm，主要好久没写C++啦</p><p>目前来看，主要任务包括课程作业、新论文、班级社团党支部事务、算法与创新竞赛。</p><h1 id="18-4-1"><a href="#18-4-1" class="headerlink" title="18-4-1"></a>18-4-1</h1><p>上午很无奈地回绝了徐老师的邀请。</p><p>下午似乎没有干啥就过去了。。操作系统作业2-5贼复杂。</p><p>晚上去听庆岩的算法讲座，发现高中算法竞赛的内容真是重要。</p><p>熬夜把操作系统作业2.5搞定了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;18-4-20&quot;&gt;&lt;a href=&quot;#18-4-20&quot; class=&quot;headerlink&quot; title=&quot;18-4-20&quot;&gt;&lt;/a&gt;18-4-20&lt;/h1&gt;&lt;p&gt;上午上完系统结构和萌主讨论了编译原理，&lt;/p&gt;
&lt;p&gt;下午终于把生产者消费者进程同步搞定了！！开心！
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《操作系统》实验2-进程控制</title>
    <link href="http://wang22ti.com/2018/03/30/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AE%9E%E9%AA%8C2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://wang22ti.com/2018/03/30/《操作系统》实验2-进程控制/</id>
    <published>2018-03-30T03:04:08.000Z</published>
    <updated>2018-03-30T03:27:09.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><strong>打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有进程的ID和父进程ID。将得到的进程树和由pstree命令的得到的进程树进行比较。</strong></p><p>解：pgrep 是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行；xargs能够捕获一个命令的输出，然后传递给另外一个命令。通过两个命令的配合，完成了显示名字为vi的进程的输出，并通过ps命令一步一步找到父进程。</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image1.png" alt="mage"></p><p>通过pstree命令得到以下的进程树：</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image2.png" alt="mage"> </p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image3.png" alt="mage"></p><p>比对两种方法获得的父进程，发现均为systemd→lightdm→upstart→gnome-terminal→bash→vi。其中，systemd是一组系统管理命令，取代了init命令成为系统的第一个进程；LightDM即Light Display Manager，是一个全新的、轻量的Linux桌面的桌面显示管理器；有趣的是，upstart是一种基于事件通知机制启动相应服务的init进程，即较早版本的Ubuntu的初始化进程为init→upstart；gnome-terminal为终端的管理进程；bash是其中一套shell规范（类似于Ubuntu和Linux的关系），而shell是一套linux接口。</p><h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h1><p><strong>编写程序，使用getpid、getppid系统调用，输出当前进程的ID以及父进程的ID。</strong></p><p>解：编写程序及其输入结果如下，不做赘述。</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image4.png" alt="mage"></p><h1 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h1><p><strong>编写程序，首先使用fork系统调用，创建子进程。在父进程中继续执行空循环操作；在子进程中调用exec编辑器。然后在另外一个终端中，通过ps –Al命令、ps aux命令，查看vi进程及其父进程的运行状态，理解每个参数所表达的意义。选择合适的命令参数，对所有进程按照cpu占用率排序。</strong></p><p>解：根据题目要求，编写程序如下，并使用命令ps -AL查看现有进程信息。查阅资料可知，</p><p>#F代表程序的旗标(flag)，4代表使用者为 superuser，1代表user；</p><p>#S代表这个程序的状态 (STAT)；</p><p>#UID代表执行者身份；</p><p>#PID代表进程的ID号</p><p>#PPID代表父进程的ID；</p><p>#C代表使用的CPU资源百分比；</p><p>#PRI代表进程的执行优先权(Priority的简写)，其值越小越早被执行；</p><p>#NI代表进程的nice值，其表示进程可被执行的优先级的修正数值；</p><p>#ADDR代表内核函数； </p><p>#SZ表示占用内存的大小；</p><p>#WCHAN表示这个程序是否正在运作当中，其中’ -’表示正在运作；</p><p>#TTY表示登入者的终端机位置；</p><p>#TIME表示使用掉的 CPU 时间；</p><p>#CMD 表示下达指令的名称；</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image5.png" alt="mage"></p><p>在右下角的中找到vi进程及其状态：</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image6.png" alt="mage"></p><p>使用命令ps aux查看内存中运行的程序，查阅资料可知：</p><p>• USER：该进程属于的使用者账号；</p><p>• PID：该进程的进程ID号；</p><p>• CPU：该进程使用掉的CPU资源百分比；</p><p>• MEM：该进程所占用的物理内存百分比；</p><p>• VSZ：该进程使用掉的虚拟内存量 (Kbytes)</p><p>• RSS ：该进程占用的固定的内存量 (Kbytes)</p><p>• TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。</p><p>• STAT：该程序目前的状态，主要的状态有：</p><p>   R ：该程序目前正在运作，或者是可被运作；</p><p>   S ：该程序目前正在睡眠当中；</p><p>   T ：该程序目前正在侦测或者是停止了；</p><p>   Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie(疆尸) 程序的状态；</p><p>• START：该进程被触发启动的时间；</p><p>• TIME ：该进程实际使用 CPU 运作的时间。</p><p>• COMMAND：该进程所属的指令</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image7.png" alt="mage"></p><p>​       使用top命令将所有进程按照cpu占有率排名，可见死循环程序fork_exec已经几乎完全占有了CPU：</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image8.png" alt="mage"></p><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><p><strong>使用fork系统调用，创建如下进程树，并使每个进程输出自己的ID和父进程的ID。观察进程的执行顺序。</strong></p><p>解：根据题目要求编写程序，多次运行得到如下输出。可以看出P1为P2和P3的父进程，P2位P4和P5的父进程，与实验要求的进程树相同。</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image9.png" alt="mage"></p><h1 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h1><p><strong>修改上述进程树中的进程，使得所有进程都循环输出自己的ID和父进程的ID。然后终止p2进程(kill或者自动退出)，观察p1、p3、p4、p5进程的运行状态和其他相关参数有何改变。</strong></p><p>解：由于需要循环输出自己的ID和父进程的ID，所以程序逻辑发生变化，重新编写程序并运行如下。5个程序并发执行，前后并无固定的顺序，但是进程ID及其父进程ID始终满足题目进程树的要求。</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image10.png" alt="mage1"></p><p>​       修改程序如下，P2只循环输出3次。观察到从第4轮输出开始除了P2没有继续输出外，其他进程仍然满足题目要求的进程树。这和我预计的结果并不一样，所以猜测可能进程P2并没有结束。</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image11.png" alt="mage1"></p><p>​       进一步修改程序如下，P2在3次输出之后执行return语句，惊奇地发现P2的子进程P4和P5的父进程均变为了1537！可见此前的程序并没有结束进程P2。使用ps命令，发现该进程名为upstart，它负责收养孤儿进程，其父进程就是ubuntu图形化界面的进程lightdm。这意味着在文本界面下，一切都和upstart无关了。</p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image12.png" alt="mage1"></p><p><img src="/2018/03/30/《操作系统》实验2-进程控制/image13.png" alt="mage1"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] linux pgrep命令的使用 </p><p><a href="https://blog.csdn.net/edman_linux/article/details/78722021" target="_blank" rel="noopener">https://blog.csdn.net/edman_linux/article/details/78722021</a></p><p>[2] Linux xargs命令小结</p><p><a href="https://blog.csdn.net/wh_19910525/article/details/8494444" target="_blank" rel="noopener">https://blog.csdn.net/wh_19910525/article/details/8494444</a></p><p>[3] Systemd 入门教程：命令篇</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></p><p>[4] 百度百科：LightDM</p><p><a href="https://baike.baidu.com/item/LightDM/9557430?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/LightDM/9557430?fr=aladdin</a></p><p>[5] linux第一个用户进程init—upstart</p><p><a href="https://blog.csdn.net/itsenlin/article/details/42329851" target="_blank" rel="noopener">https://blog.csdn.net/itsenlin/article/details/42329851</a></p><p>[6] 知乎：想了解一下ubuntu下的终端，shell，bash是什么以及区别？</p><p><a href="https://www.zhihu.com/question/40448945" target="_blank" rel="noopener">https://www.zhihu.com/question/40448945</a></p><p>[7] Linux ps命令详解与示例说明</p><p><a href="https://blog.csdn.net/lsbhjshyn/article/details/18549869" target="_blank" rel="noopener">https://blog.csdn.net/lsbhjshyn/article/details/18549869</a></p><p>[8] Ubuntu15.04 删除/sbin/upstart与孤儿进程收养的问题</p><p><a href="https://www.cnblogs.com/chilumanxi/p/5136102.html" target="_blank" rel="noopener">https://www.cnblogs.com/chilumanxi/p/5136102.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《计算机体系结构》实验1-计算机性能测试</title>
    <link href="http://wang22ti.com/2018/03/29/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E3%80%8B%E5%AE%9E%E9%AA%8C1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://wang22ti.com/2018/03/29/《计算机体系结构》实验1-计算机性能测试/</id>
    <published>2018-03-28T17:04:40.000Z</published>
    <updated>2018-03-30T03:28:01.493Z</updated>
    
    <content type="html"><![CDATA[<p>#背景介绍</p><p>本次实验中，我共计采用5种方式（4个成熟的测试软件和1个自己写的小程序）对3台计算机（期间对联想小新V4000进行固态的改装升级）进行了全方位的测试，具体方案如下表所示：</p><table><thead><tr><th></th><th><strong>MIIX 5Pro</strong></th><th><strong>小新V4000</strong>  <strong>（改装固态）</strong></th><th><strong>小新V4000</strong>  <strong>（未改装）</strong></th><th><strong>方正</strong>  <strong>Wenxiang E620</strong></th></tr></thead><tbody><tr><td><strong>鲁大师</strong></td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><strong>CrystalDisk</strong></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td><strong>CPU-Z</strong></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td><strong>Performance Test 9</strong></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td><strong>My benchmark</strong></td><td>√</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><p>​        此外，根据鲁大师、CPU-Z的检测结果，3台计算机主要的软硬件配置如下表所示：</p><p> <img src="/2018/03/29/《计算机体系结构》实验1-计算机性能测试/1.png" alt="1"></p><p>#测试过程与结果分析</p><p>##鲁大师磁盘测试</p><p>鲁大师磁盘检测的健康程度取决于访问该存储单元的响应时间。小于三毫秒为优秀，小于12毫秒为良好，是小于20毫秒为正常，小于120毫秒为瑕疵，小于600毫秒为丢失，大于600毫秒为严重，无法读取为损坏。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优良</th><th style="text-align:center">良好</th><th style="text-align:center">正常</th><th style="text-align:center">瑕疵</th><th style="text-align:center">丢失</th></tr></thead><tbody><tr><td style="text-align:center">方正</td><td style="text-align:center"><strong>1779866</strong></td><td style="text-align:center"><strong>69891</strong></td><td style="text-align:center"><strong>20114</strong></td><td style="text-align:center"><strong>12976</strong></td><td style="text-align:center"><strong>712</strong></td></tr><tr><td style="text-align:center">小新_旧</td><td style="text-align:center"><strong>2185385</strong></td><td style="text-align:center"><strong>275919</strong></td><td style="text-align:center"><strong>11963</strong></td><td style="text-align:center"><strong>37386</strong></td><td style="text-align:center"><strong>1750</strong></td></tr><tr><td style="text-align:center">小新_新</td><td style="text-align:center"><strong>951431</strong></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>0</strong></td></tr><tr><td style="text-align:center">MIIX</td><td style="text-align:center"><strong>1953524</strong></td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center"><strong>0</strong></td></tr></tbody></table><p>从上表的测试结果可以看出，在经过一段时间的使用后，机械硬盘具有明显的损耗，小部分存储单元延迟较长；而固态硬盘，具有良好的稳定性，在一段时间的使用之后仍然保持优良的健康状态。</p><p>##鲁大师性能测试</p><p>鲁大师的计算机性能测试，包括处理器、显卡、内存和硬盘。总分是根据各个属性加权求和得到。</p><table><thead><tr><th></th><th>总分</th><th>处理器</th><th>显卡</th><th>内存</th><th>硬盘</th></tr></thead><tbody><tr><td>方正</td><td><strong>58240</strong></td><td><strong>46696</strong></td><td><strong>3651</strong></td><td><strong>6963</strong></td><td><strong>930</strong></td></tr><tr><td>小新_旧</td><td><strong>70953</strong></td><td><strong>32486</strong></td><td><strong>28744</strong></td><td><strong>8223</strong></td><td><strong>1500</strong></td></tr><tr><td>小新_新</td><td><strong>96665</strong></td><td><strong>32728</strong></td><td><strong>26217</strong></td><td><strong>8223</strong></td><td><strong>10860</strong></td></tr><tr><td>MIIX</td><td><strong>126353</strong></td><td><strong>39076</strong></td><td><strong>11722</strong></td><td><strong>9006</strong></td><td><strong>42960</strong></td></tr></tbody></table><p>通过分析上表数据，可以得到一些结论：</p><p>越新的计算机测试总分越高，这符合计算机发展的常识与我日常使用的体验；</p><p>近几代英特尔处理器升级幅度并不是很大；</p><p>得益于较大的功率，桌面级处理器相较于笔记本级处理器具有较大优势；</p><p>独立显卡具有碾压于核心显卡的处理能力，不过近几年核心显卡有了较大的发展；</p><p>近几年内存升级幅度并不是很大；</p><p>固态硬盘具有碾压机械硬盘的传输速度。</p><p>##CrystalDisk</p><p>​      CrystalDisk测试主要包括硬盘的顺序读写、4k读写，其中比较容易理解的顺序读写结果如下：</p><table><thead><tr><th></th><th><strong>Read(MB/s)</strong></th><th><strong>Write(MB/s)</strong></th></tr></thead><tbody><tr><td>小新_新</td><td><strong>561.9</strong></td><td><strong>305.5</strong></td></tr><tr><td>MIIX</td><td><strong>2041.2</strong></td><td><strong>1588.4</strong></td></tr></tbody></table><p>可以看出，固态硬盘之间也有较大差距。查阅相关资料可知，这主要取决于固态硬盘的闪存颗粒、主控芯片以及接口规格。不过从实际体验来看，SATA3固态硬盘的500MB/s读取速度与300MB/s写入速度已经满足了日常的基本需求，实际体验没有太大的差别。</p><p>##CPU-Z</p><p>​        CPU-Z测试主要包括处理器的单核性能和多核性能。</p><table><thead><tr><th></th><th><strong>单核</strong></th><th><strong>多核</strong></th></tr></thead><tbody><tr><td><strong>小新_新</strong></td><td><strong>322.7</strong></td><td><strong>895.3</strong></td></tr><tr><td><strong>MIIX</strong></td><td><strong>344.2</strong></td><td><strong>1002.7</strong></td></tr></tbody></table><p>从上表可知，虽然代数相差两代，但是i7 7500U相较于i7 5500U并没有显著的提升。两款CPU的功耗、工艺、核心数量、线程数量制成完全相同，区别主要在于架构和主频。单从处理性能来看，英特尔牙膏厂的称号名副其实，可见垄断并不利于技术的进步。</p><p>##Performance Test 9</p><p>​        PerformanceTest 9测试内容主要包括CPU、2d图形、3d图形、内存和磁盘。这些属性和鲁大师的相似，2d图形和3d图形相比更看重CPU的处理能力。</p><table><thead><tr><th></th><th><strong>PassMark</strong></th><th><strong>CPU</strong></th><th><strong>2D图形</strong></th><th><strong>3D图形</strong></th><th><strong>内存</strong></th><th><strong>磁盘</strong></th></tr></thead><tbody><tr><td><strong>小新_新</strong></td><td><strong>2214.3</strong></td><td><strong>4284.8</strong></td><td><strong>617.2</strong></td><td><strong>550.9</strong></td><td><strong>1720.1</strong></td><td><strong>5443.1</strong></td></tr><tr><td><strong>MIIX</strong></td><td><strong>2186.2</strong></td><td><strong>5534.9</strong></td><td><strong>460.3</strong></td><td><strong>453.0</strong></td><td><strong>2341.8</strong></td><td><strong>19460.6</strong></td></tr></tbody></table><p>令人意外的是，上表显示比较老旧的联想小新获得了更高的总分，这一方面可能是因为硬盘在该项测试中所占权重较小，另一方面可能是因为联想小新具有更大的机身体积，故而具有较好的散热。由此可见，计算机性能测试的标准并不唯一，每一项属性所占的权重因人而异；同时，计算机的性能参数并不是决定计算机最终实际使用性能的唯一指标。</p><p>##My benchmark</p><p>​      除了使用上述的成熟软件，我还编写了以下的python3.5程序，以测试不同电脑的性能。</p><p>​        每次测试要按不同次数执行三个操作。其中，第一个操作是整数0到1000万的累加，主要考察CPU的整数加法计算能力；第二个操作是1到1万的阶乘，主要考察CPU的整数乘法计算能力；第三个操作是，对17MB纯文本文件的读写，文本内容为所有维基百科的词条，主要考察计算机的IO读写速度。四次测试中，三种操作的频数之比分别为10:10:10，28:1:1，1:28:1，1:1:28。</p><table><thead><tr><th></th><th>T1(s)</th><th>T2(s)</th><th>T3(s)</th><th>Ttotal(s)</th></tr></thead><tbody><tr><td>小新V4000</td><td></td><td></td><td></td><td></td></tr><tr><td>[10,  10, 10]</td><td>11.19</td><td>1.33</td><td>22.34</td><td>34.87</td></tr><tr><td>[28,  1, 1]</td><td>31.30</td><td>0.13</td><td>2.23</td><td>33.67</td></tr><tr><td>[1,  28, 1]</td><td>1.15</td><td>3.70</td><td>2.26</td><td>7.11</td></tr><tr><td>[1,  1, 28]</td><td>1.11</td><td>0.13</td><td>62.62</td><td>63.87</td></tr><tr><td>MIIX  5pro</td><td></td><td></td><td></td><td></td></tr><tr><td>[10,  10, 10]</td><td>10.37</td><td>1.12</td><td>6.84</td><td>28.33</td></tr><tr><td>[28,  1, 1]</td><td>28.7</td><td>0.11</td><td>1.68</td><td>30.56</td></tr><tr><td>[1,  28, 1]</td><td>1.01</td><td>3.08</td><td>1.68</td><td>5.77</td></tr><tr><td>[1,  1, 28]</td><td>1.06</td><td>0.11</td><td>47.3</td><td>48.5</td></tr></tbody></table><p>测试的结果比较符合预期，即两者在CPU的处理能力上相差不大，而MIIX在磁盘读写的能力上有明显的优势。此外，本实验中操作三在总时长中占比较大，真实应用场景中，应该对相应的操作进行优化，从而有效的提高全局加速比。</p><h1 id="购机建议"><a href="#购机建议" class="headerlink" title="购机建议"></a>购机建议</h1><p>根据上述实验结论，提出以下的购机建议：</p><p>受制于笔记本功耗与工艺制成的阻碍，低压版处理器实际性能相距不大，散热成为实际性能的瓶颈。</p><p>独立显卡具有碾压核心显卡的处理能力，有游戏、大型图像处理以及机器学习需求的用户需要购买较为高端的显卡。</p><p>硬盘的读写速度是制约当前计算机实际使用体验的重要瓶颈。在预算充足的情况下，尽量购买带有固态硬盘的计算机。</p><p>由于软件的更新升级，内存容量的大小建议8G起步。</p><p>计算机的实际使用体验不仅取决于各项性能参数，还取决于显示器键盘触控板等外设的质量、配备接口的数量与质量、实际做工以及硬件之间的配合程度，不能陷入单纯比较参数的陷阱当中，一切以实际的使用体验为准。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验中，我首先使用四种成熟的测试软件对个人的两台计算机和机房的计算机进行性能测试，然后又自己编写python程序测试个人的两台计算机性能，得到了一系列实验数据，并分析得到相关实验结论。</p><p>通过本次实验，我从总体上了解了计算机测试的各项指标，验证了课堂上所学的相关知识与课下了解的近几年计算机发展状况，同时对个人的计算机状况有了较为深入的理解，这些必将有利于我进一步的学习与实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#背景介绍&lt;/p&gt;
&lt;p&gt;本次实验中，我共计采用5种方式（4个成熟的测试软件和1个自己写的小程序）对3台计算机（期间对联想小新V4000进行固态的改装升级）进行了全方位的测试，具体方案如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小团队管理概论</title>
    <link href="http://wang22ti.com/2018/03/26/%E5%B0%8F%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E6%A6%82%E8%AE%BA/"/>
    <id>http://wang22ti.com/2018/03/26/小团队管理概论/</id>
    <published>2018-03-26T15:37:51.000Z</published>
    <updated>2018-03-26T15:37:51.135Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小团队协作概论</title>
    <link href="http://wang22ti.com/2018/03/26/%E5%B0%8F%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%A6%82%E8%AE%BA/"/>
    <id>http://wang22ti.com/2018/03/26/小团队协作概论/</id>
    <published>2018-03-26T15:37:43.000Z</published>
    <updated>2018-03-26T15:37:43.917Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>联想小新V4000安装固态硬盘</title>
    <link href="http://wang22ti.com/2018/03/26/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0V4000%E5%AE%89%E8%A3%85%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/"/>
    <id>http://wang22ti.com/2018/03/26/联想小新V4000安装固态硬盘/</id>
    <published>2018-03-26T15:37:17.000Z</published>
    <updated>2018-03-30T15:30:43.566Z</updated>
    
    <content type="html"><![CDATA[<p>计算机体系结构第一次上机做性能检测，好吧惊讶地发现小新V4000的硬盘已经老化了不少，考虑到非优秀良好的单元虽然数量占比并不是很高但是响应时间占比却吓人，于是就考虑换一下硬盘。<img src="/2018/03/26/联想小新V4000安装固态硬盘/磁盘检测.PNG" alt=""></p><p>原来是想换联想原装的，然而悲哀的发现同等容量（200多G）同等接口（SATA3）下三星的反而更快（500对300）更便宜（可能刚好赶上秒杀？），于是就入了<a href="https://item.jd.com/6287165.html" target="_blank" rel="noopener">三星(SAMSUNG) 860 EVO 250G SATA3 固态硬盘（MZ-76E250B）</a>。</p><p>由于此前没有拆机的经历啦（愧为计算机人），所以请南门的小哥帮忙装一下（顺便观察一波）。</p><p>最后把固态安装在主硬盘，原来的机械扔在光驱上。然而小新V4000的光驱位很草率，就是一个塑料壳，根本没考虑拓展，于是又从小哥那里买了一个支架。</p><p>回来后就很愉快啦，装了Win10，发现STAT3接口的速度已经足够使用，完全不是瓶颈了。</p><p><img src="/2018/03/26/联想小新V4000安装固态硬盘/硬盘测试.png" alt=""></p><p>不过原装的希捷硬盘貌似应为工作电流较大的原因，经常掉盘。。大概只能买一个盒子当移动硬盘了。</p><p>参考资料主要有：<a href="https://club.lenovo.com.cn/thread-1881162-1-1.html" target="_blank" rel="noopener">完美解决联想小新V4000光驱位无法识别硬盘+加固态最简单教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机体系结构第一次上机做性能检测，好吧惊讶地发现小新V4000的硬盘已经老化了不少，考虑到非优秀良好的单元虽然数量占比并不是很高但是响应时间占比却吓人，于是就考虑换一下硬盘。&lt;img src=&quot;/2018/03/26/联想小新V4000安装固态硬盘/磁盘检测.PNG&quot; a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《操作系统》实验1_操作系统初步</title>
    <link href="http://wang22ti.com/2018/03/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AE%9E%E9%AA%8C1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%AD%A5/"/>
    <id>http://wang22ti.com/2018/03/15/《操作系统》实验1-操作系统初步/</id>
    <published>2018-03-15T15:49:44.000Z</published>
    <updated>2018-03-15T16:18:16.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><p><strong>根据以下代码完成下面的实验。</strong><br><strong>要求：</strong><br><strong>1、编译运行该程序（cpu.c），观察输出结果，说明程序功能。(编译命令： gcc -o cpu cpu.c –Wall)（执行命令：./cpu）</strong><br><strong>2、再次按下面的命令运行并观察结果。程序cpu运行了几次？他们运行的顺序有何特点和规律？你能尝试解释吗？（执行命令：./cpuA &amp; ; ./cpu B &amp; ; ./cpu C &amp; ; ./cpu D &amp;）</strong></p><p>1、 程序功能为每隔一秒输出一次参数<br>2、 我对程序稍加改造如下，将打印的结果输出到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetTime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">int</span> rc=gettimeofday(&amp;t,<span class="literal">NULL</span>);</span><br><span class="line">assert(rc==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)t.tv_sec+(<span class="keyword">double</span>)t.tv_usec/<span class="number">1e6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin</span><span class="params">(<span class="keyword">int</span> howlong)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> t=GetTime();</span><br><span class="line"><span class="keyword">while</span>((GetTime()-t)&lt;(<span class="keyword">double</span>)howlong);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: cpu &lt;string&gt;\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; j &lt; <span class="number">60</span>;j++) &#123;</span><br><span class="line">spin(<span class="number">1</span>);</span><br><span class="line">FILE *stream = fopen(<span class="string">"log.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">"%d %s\n"</span>, i, str);</span><br><span class="line">fclose(stream);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, i++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line">FILE *stream = fopen(<span class="string">"log.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">"******************\n"</span>);</span><br><span class="line">fclose(stream);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终ABCD四个程序分别运行了60次，其中部分输出如下：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/1521129185256.png" alt=""><br>可见4个程序在每一轮循环中轮流执行，并没有发现特别的规律。<br>解释：对于4个完全相同的程序，CPU的优先级是相同的，因此会随机地顺序执行。<br>之后通过命令行去随机化：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/1.png" alt=""><br>以相同的方式再次运行程序，可以得到以下结果：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/2.png" alt=""><img src="/2018/03/15/《操作系统》实验1-操作系统初步/2.png" alt=""><img src="/2018/03/15/《操作系统》实验1-操作系统初步/3.png" alt=""><br>可以看到，除了第0-2循环，其他均以“DACB”的顺序打印，可见此时CPU已经不再使用之前的随机算法。</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p><strong>根据以下代码完成实验。</strong><br><strong>要求：</strong><br><strong>1、阅读并编译运行该程序(mem.c)，观察输出结果，说明程序功能。(命令： gcc -o mem mem.c –Wall)</strong><br><strong>2、再次按下面的命令运行并观察结果。两个分别运行的程序分配的内存地址是否相同？是否为同一块内存区域？为什么？命令：./mem &amp;; ./mem &amp;</strong></p><p>1、 程序功能为打印指针p指向的内存地址，以及每隔一秒将指针加一后打印指针的相对地址。<br>2、 我对程序稍加改造如下，将打印的结果输出到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetTime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">int</span> rc=gettimeofday(&amp;t,<span class="literal">NULL</span>);</span><br><span class="line">assert(rc==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">double</span>)t.tv_sec+(<span class="keyword">double</span>)t.tv_usec/<span class="number">1e6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spin</span><span class="params">(<span class="keyword">int</span> howlong)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> t=GetTime();</span><br><span class="line"><span class="keyword">while</span>((GetTime()-t)&lt;(<span class="keyword">double</span>)howlong);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// a1</span></span><br><span class="line">assert(p != <span class="literal">NULL</span>);</span><br><span class="line">FILE *stream = fopen(<span class="string">"2log.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">"(%d) address pointed to by p: %p\n"</span>,getpid(), p); <span class="comment">// a2</span></span><br><span class="line">fclose(stream);</span><br><span class="line">*p = <span class="number">0</span>; <span class="comment">// a3</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">Spin(<span class="number">1</span>);</span><br><span class="line">*p = *p + <span class="number">1</span>;</span><br><span class="line">FILE *stream = fopen(<span class="string">"2log.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">"(%d) p: %d\n"</span>, getpid(), *p); <span class="comment">// a4</span></span><br><span class="line">fclose(stream);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最终输出如下：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/5.png" alt=""><br>可见两次指针p指向的地址并不相同，并不是同一内存区域。<br>解释：操作系统为不同的指针分配不同的地址，同时为了避免指针之间的冲突，所以不能把不同的指针指向同一内存区域。</p><h1 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h1><p><strong>根据以下代码完成实验。</strong><br><strong>要求：</strong><br><strong>1、阅读并编译运行该程序，观察输出结果，说明程序功能。（编译命令：gcc -o thread thread.c -Wall –pthread）（执行命令1：./thread 1000）</strong><br><strong>2、尝试其他输入参数并执行，并总结执行结果的有何规律？你能尝试解释它吗？（例如执行命令2：./thread 100000）（或者其他参数。）</strong></p><p>1、 程序功能为并发两个线程对同一变量进行若干次加一操作，并输出变量初值与终值。<br>2、 实验说明中的代码在我这里并不能执行，修改程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> loops;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: threads &lt;value&gt;\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">loops = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Initial value : %d\n"</span>, counter);</span><br><span class="line"></span><br><span class="line">pthread_create(&amp;p1, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;p2, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Final value : %d\n"</span>, counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，其中pthread由于不是标准库所以编译语句要加上-pthread：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/6.png" alt=""><br>可见终值与初值的差为输入参数的两倍。<br>解释：虽然开了两个线程，但是两个线程均对同一变量进行加一操作，参数即为循环的次数，所以为输入参数的两倍。</p><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><p><strong>系统调用实验，了解系统调用不同的封装形式。</strong><br><strong>要求：参考下列网址中的程序。阅读分别运行用API接口函数getpid()直接调用和汇编中断调用两种方式调用Linux操作系统的同一个系统调用getpid的程序。请问getpid的系统调用号是多少？系统调用的中断向量号是多少？你可以采用汇编中断调用形式调用其他的系统调用吗？</strong><br><strong><a href="http://hgdcg14.blog.163.com/blog/static/23325005920152257504165/" target="_blank" rel="noopener">http://hgdcg14.blog.163.com/blog/static/23325005920152257504165/</a></strong></p><p>仿照博客里的代码，我编写并编译执行了两个C文件getpid_c.c和getpid_huibina.c如下：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/7.png" alt=""><br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/8.png" alt=""><br>getpid的系统调用号为0x14，中断向量为0x80。<br>可以调用其他系统函数，64位系统内核内函数的具体实现和系统调用函数之间的对应关系通过如下文件syscall_64.tbl来记录，就可以使用汇编调用。<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/9.png" alt=""><br>我尝试了open函数的嵌入式汇编的调用，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> file = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* src = <span class="string">"log.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov $0, %%ebx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov $0x5, %%eax\n\t"</span>   <span class="comment">//open的系统调用号为0x5</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %1, %%ebx\n\t"</span>     <span class="comment">//将文件地址赋给第一个参数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov $0002, %%ecx\n\t"</span>  <span class="comment">//立即数2表示O_RDWR，即可读可写</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov $0644, %%edx\n\t"</span>  <span class="comment">//立即数0644表示文件的访问权限。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"int $0x80\n\t"</span>          <span class="comment">//中断，系统调用</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%eax, %0\n\t"</span>     </span></span></span><br><span class="line"><span class="function"><span class="params">:<span class="string">"=m"</span>(file)</span></span></span><br><span class="line">:"b"(src)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"file: %d\n"</span>, file);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而直接编译会有报错如下：<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/10.png" alt=""><br>原因是我的虚拟机是64位的Ubuntu，mov是一个32位的api，因此需要在asm_open.c之前加上-m32的配置。同时由于缺少部分C语言的库，还需要通过指令sudo apt-get install build-essential libc6-dev libc6-dev-i386命令完成安装，整个过程如下<br><img src="/2018/03/15/《操作系统》实验1-操作系统初步/11.png" alt=""><br>可见file的值变为了-14，成功进行了系统调用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过本次实验，我初次体验了Linux环境下CPU、内存、进程和系统调用，并通过查阅资料在给定代码的基础上进行一定程度的修改，完成预定的实验任务，相信对于操作系统进一步的学习有积极的影响。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Ubuntu关闭地址空间随机化(ASLR)的方法 <a href="http://www.xuebuyuan.com/1571079.html" target="_blank" rel="noopener">http://www.xuebuyuan.com/1571079.html</a><br>[2] Linux下undefinedreference to ‘pthread_create’问题解决 <a href="http://blog.csdn.net/jiangxinyu/article/details/7778864" target="_blank" rel="noopener">http://blog.csdn.net/jiangxinyu/article/details/7778864</a><br>[3] 系统调用的两种实现方法及对系统调用的理解 <a href="http://hgdcg14.blog.163.com/blog/static/23325005920152257504165/" target="_blank" rel="noopener">http://hgdcg14.blog.163.com/blog/static/23325005920152257504165/</a><br>[4] 使用嵌入汇编调用open系统调用 <a href="http://blog.csdn.net/u013511711/article/details/50933854" target="_blank" rel="noopener">http://blog.csdn.net/u013511711/article/details/50933854</a><br>[5] gcc嵌入汇编Error:unsupported for `mov’ 错误解决方法 <a href="http://mblog.sigma.me/2012/11/26/gcc%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96error-unsupported-for-mov-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">http://mblog.sigma.me/2012/11/26/gcc%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96error-unsupported-for-mov-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</a><br>[6] ubuntu x64下编译出现找不到 cdefs.h / c++config.h的问题 <a href="http://blog.csdn.net/sfdazsdf/article/details/48625545" target="_blank" rel="noopener">http://blog.csdn.net/sfdazsdf/article/details/48625545</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、&quot;&gt;&lt;a href=&quot;#一、&quot; class=&quot;headerlink&quot; title=&quot;一、&quot;&gt;&lt;/a&gt;一、&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;根据以下代码完成下面的实验。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;要求：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1、编
      
    
    </summary>
    
      <category term="课程" scheme="http://wang22ti.com/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="课程" scheme="http://wang22ti.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="http://wang22ti.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="C" scheme="http://wang22ti.com/tags/C/"/>
    
      <category term="汇编" scheme="http://wang22ti.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>读书_《编码》</title>
    <link href="http://wang22ti.com/2018/03/02/%E8%AF%BB%E4%B9%A6-%E3%80%8A%E7%BC%96%E7%A0%81%E3%80%8B/"/>
    <id>http://wang22ti.com/2018/03/02/读书-《编码》/</id>
    <published>2018-03-02T03:12:35.000Z</published>
    <updated>2018-03-02T03:12:36.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日记18-3</title>
    <link href="http://wang22ti.com/2018/02/28/%E6%97%A5%E8%AE%B018-3/"/>
    <id>http://wang22ti.com/2018/02/28/日记18-3/</id>
    <published>2018-02-28T15:46:47.000Z</published>
    <updated>2018-03-31T16:46:36.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="18-3-31"><a href="#18-3-31" class="headerlink" title="18-3-31"></a>18-3-31</h1><p>上午和鑫云到志悦的班级分享经验。</p><p>下午做了部分《操作系统》作业，设计了一个课程报告的模板，</p><p>软件工程的作业开了个头。</p><p>晚上去下棋，互相捡漏子。。</p><p>到楼下还给两个留学生充了20元电费。。</p><p>给高时清买的手机到了，不过屏幕竟然不灵敏。。不科学。。</p><p>好久没写C++了，竟然连</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>都不知道加了。。菜哭</p><a id="more"></a><h1 id="18-3-30"><a href="#18-3-30" class="headerlink" title="18-3-30"></a>18-3-30</h1><p>上午起来看了《暴走大事件》，又帮笑佟学姐改了一波代码。</p><p>好好收拾了一波床铺。</p><p>晚上办了宣讲团，关于保研，效果还不错。</p><p>算法的学习还是得选择C++</p><h1 id="18-3-29"><a href="#18-3-29" class="headerlink" title="18-3-29"></a>18-3-29</h1><p>下午软件比赛中期答辩，实际评审和宣传的不一样啊。。</p><p>关键是举办方的组织能力实在堪忧，电脑竟然可以没电。。</p><p>晚上学术会开会，光速。</p><p>回来完成了操作系统的实验报告。</p><p>终于不那么紧张了。</p><h1 id="18-3-28"><a href="#18-3-28" class="headerlink" title="18-3-28"></a>18-3-28</h1><p>写好了体系结构的作业，嘎嘎</p><p>晚上CITeam开会，可以奋斗的时间不多了。</p><p>不能再研究P20了。。</p><h1 id="18-3-27"><a href="#18-3-27" class="headerlink" title="18-3-27"></a>18-3-27</h1><p>上午和袁锐去教材中心把班级的欠款补了</p><p>申请了一个学术的lisence， 装了一套jetbrain的软件，这下终于可以写c和java了</p><p>下午的小米发布会，MIX2s、游戏笔记本。</p><p>晚上华为发布会，P20(Pro)、Mate RS，拍照屠榜了。</p><p>真高兴生活在这个日新月异的时代。</p><p>把操作系统和计算机系统结构的实验做了，</p><p>明天疯狂写文档。</p><h1 id="18-3-26"><a href="#18-3-26" class="headerlink" title="18-3-26"></a>18-3-26</h1><p>嗯……根据今天的测试，在压力正常的情况下，2点睡有点迟。。</p><p>和朱老师联系了一下。</p><p>晚上在学活二楼吃香锅，巨饱，回来就睡。</p><p>醒来终于把《编译原理》第二章作业做好交上去了，</p><p>感觉关于短语的知识还不清晰。。但至少有点感觉了。</p><p>宣讲团的通知发出来了，关于保研。</p><p>斟酌了一番，觉得还是在旧电脑上装双系统比较好。。</p><p>MIIX的确不太适合跑沉重的任务</p><h1 id="18-3-25"><a href="#18-3-25" class="headerlink" title="18-3-25"></a>18-3-25</h1><p>固态到啦，去南门的小店里装上了</p><p>顺便观察了一波，下次应该可以自己拆机了，嘻嘻。</p><p>四食堂二楼的香锅，第一次搞错了次序，第二次搞错了口味，第三次搞错了咸淡。。</p><p>装了一下午软件，啊，要做作业啊！</p><p>晚上基本把《编译原理》作业做好了。</p><p>科研经验给我带来了不错的文案编辑能力，啊。</p><h1 id="18-3-24"><a href="#18-3-24" class="headerlink" title="18-3-24"></a>18-3-24</h1><p>穿上一身帅气的西装，大创答辩终于结束啦！希望有个好结果！</p><p>最辛苦的阶段终于过去了！</p><p>要疯狂操作一波作业啦，还有论文。</p><p>下午和晚上和嘉哥、翔哥交流，说了憋了一星期的语句。</p><p>晚上买了块三星的250G固态，嘻嘻。</p><h1 id="18-3-23"><a href="#18-3-23" class="headerlink" title="18-3-23"></a>18-3-23</h1><p>啊，结题报告、答辩PPT、网站后天，疯狂操作了一天</p><h1 id="18-3-22"><a href="#18-3-22" class="headerlink" title="18-3-22"></a>18-3-22</h1><p>上午《编译原理》小测，末了和徐老师有所交流，幸运。</p><p>啊，建模，建模，代码，代码，疯狂操作。。</p><h1 id="18-3-21"><a href="#18-3-21" class="headerlink" title="18-3-21"></a>18-3-21</h1><p>中午和昶霆一起开了班长支书会议，关于团日活动。</p><p>继续写代码。。</p><p>终于把评价的部分旰完了，接下来是推荐部分。。</p><p>尝试建立团日活动工作组。。失败</p><h1 id="18-3-20"><a href="#18-3-20" class="headerlink" title="18-3-20"></a>18-3-20</h1><p>上午打磨好了百度api的调用，又多了一些经验，嘿嘿。</p><p>比如调包一定要卸载try-except中。</p><p>下午继续写程序，弄标签。</p><p>其间讨论了创业比赛的ppt，班级体测的时间。</p><p>5点半找童老师讨论学习部事宜，不顺利。</p><p>晚上继续写代码，标签贴好了。</p><p>回来把周日创新比赛答辩的ppt改好了。</p><p>感谢袁锐送我的酸奶，大盒的。</p><p>一定要撑住，一定。</p><h1 id="18-3-19"><a href="#18-3-19" class="headerlink" title="18-3-19"></a>18-3-19</h1><p>从下午一起来就不停地写大创代码，</p><p>完成了数据的清洗和百度api调用的初步实现，还需要打磨一些情况。</p><h1 id="18-3-18"><a href="#18-3-18" class="headerlink" title="18-3-18"></a>18-3-18</h1><p>又忙活了一上午，终于把创青春的电子稿搞定啦！</p><p>还有很多事情，作业、大创、软件比赛的ppt……</p><p>休息了一下午，看了龙珠超，要继续干活啦！</p><p>晚上完成了作业和软件比赛ppt提纲的撰写，舍弃了学习部第二次例会。</p><p>论文状态还是没变啊啊</p><h1 id="18-3-17"><a href="#18-3-17" class="headerlink" title="18-3-17"></a>18-3-17</h1><p>啊，和浩珉浩男写了一天的创新创业比赛，</p><p>这几乎是数学建模的节奏了。</p><h1 id="18-3-16"><a href="#18-3-16" class="headerlink" title="18-3-16"></a>18-3-16</h1><p>啊……上午没有课就起得很迟，这不行……</p><p>给Ubuntu换了一个清华的源，瞬间感觉这是一个健全的系统。</p><p>下午到9点和浩男浩珉又做了创新创业的比赛，效率还不错，还得加油。</p><p>晚上学生会开会，给部长们又交代了一些事情。</p><p>完成了小米云的重新备份。</p><p>修好了mathtype和office不兼容的问题，有时间写一篇。</p><h1 id="18-3-15"><a href="#18-3-15" class="headerlink" title="18-3-15"></a>18-3-15</h1><p>啊，早上编译原理跑错教室了。。尴尬</p><p>在捷波朗的官网下载了相关应用，越来越感觉好用。</p><p>花了一下午的时间重新搭了博客，两个git一定要都设置好才能deploy，坑惨了</p><p>gurobi半天都激活不了，后来发现是已经过期了，又申请了一个。</p><p>晚上又把操作系统的实验认真做了一遍，解决了不少问题，开心！</p><h1 id="18-3-14"><a href="#18-3-14" class="headerlink" title="18-3-14"></a>18-3-14</h1><p>下午把电脑拿回来啦！</p><p>重装系统，安装软件，配置环境，忙活了好久。。</p><p>捷波朗的耳机到啦！试了试感觉还不错，只不错貌似因为开会没法下载软件了</p><p>晚上和浩珉浩男初步做了创新创业的比赛，但是效率好低。</p><p>时清漏掉了评论的爬取，大创又得延迟，时间太紧张了。</p><p>熬夜把操作系统的实验完成了，一下就到了3点。。要完</p><h1 id="18-3-13"><a href="#18-3-13" class="headerlink" title="18-3-13"></a>18-3-13</h1><p>啊，鼻炎又犯了，上午和袁锐去了一趟校医院。</p><p>回来吃了药，一觉又睡到了3点多。。</p><p>收到了白佳灏的明信片！好开心！一定要早点回信！</p><p>又问了一下《控制理论与应用》的编辑部，可以不用latex排版投稿！</p><p>开心，很快把稿件投了出去，祝好运。</p><p>联想售后通知我电脑修好了，我很怀疑只是重装了系统。。明天去看看吧</p><p>极端不幸的情况似乎在好转，祝福~</p><h1 id="18-3-12"><a href="#18-3-12" class="headerlink" title="18-3-12"></a>18-3-12</h1><p>一早起来去知春路的联想售后一趟，要过好几天用机械硬盘的生活了。。。</p><p>老实讲，排除便携性和开机速度，旧电脑并不是不能忍。</p><p>啊……午觉睡到了3点多，可以说很堕落了。</p><p>啊，阿里云连不上，稿件因为积压严重被退稿，电脑又坏了，可以说是很不幸的了。。。</p><p>啊啊啊，心态爆炸，假装镇定。</p><p>啊，百度云的api真好用，就是他了。</p><p>测试一圈下来，对于我输入的单个句子，无论是积极概率还是置信区间，效果都很差。</p><p>但是我尝试用京东和慕课学院的评价时，效果却异常地好。</p><p>真奇怪。</p><h1 id="18-3-11"><a href="#18-3-11" class="headerlink" title="18-3-11"></a>18-3-11</h1><p>哇，可能是昨天玩游戏的报应吧，MIIX 5pro坏了。。。</p><p>开机一会就死机。。。</p><p>折腾了一天，重装系统都不行。。。</p><p>啊，一天就这样流逝了。。</p><p>装系统的时候不应该玩《魔法禁书目录》的。。</p><p>真是倒霉的时候喝水都塞牙。。不幸啊。。</p><h1 id="18-3-10"><a href="#18-3-10" class="headerlink" title="18-3-10"></a>18-3-10</h1><p>snownlp貌似很久没更新了，BAT都有nlp的包，看来还是得调API。</p><p>emmmm，忙活了一个下午，终于把论文有改了一版投出去了。</p><p>回来忽然想玩地下城，倒腾了一个多小时，手累。</p><p>我地下城的角色还真不少。</p><h1 id="18-3-9"><a href="#18-3-9" class="headerlink" title="18-3-9"></a>18-3-9</h1><p>上午原本想把Ubuntu弄成Mac界面，结果越弄越乱，算了。</p><p>哇，下午一起来就收到退稿的邮件，原因是新的规定不接受本科生第一作者。</p><p>哇，早说嘛，以后投稿都要打电话问一问编辑部，emmmm。</p><p>赶紧另选了一家《铁道学报》，找任老师王老师盖了章，明天投出去。</p><p>晚上学习部开会，气氛很好，这学期应该很有作为。</p><p>可能是最没有成果的一天了。</p><p>晚上回来了解了一下jieba以外的nlp库，处理中文的，snownlp看起来不错。</p><h1 id="18-3-8"><a href="#18-3-8" class="headerlink" title="18-3-8"></a>18-3-8</h1><p>把维基百科所有的词条整理好了！开心</p><p>中午开了主席团的会，2个小时，妈耶，被批评了一通，看来要落实一些事情。</p><p>下午和浩珉、浩男讨论了两个创业比赛的大体方向，</p><p>还和浩男讨论了学习部一学期的安排。</p><p>晚上和浩珉吃牛肉拉面，另加的滑蛋真不错，还认识了张博。</p><p>看到今晚的朋友圈，感觉全世界都在健身。</p><p>又找了一些中文的词库，维基百科的几乎是严肃的名词，必然是不够的。</p><p>给学校邮箱加了一个别名<a href="mailto:wangzitai@bjtu.edu.cn" target="_blank" rel="noopener">wangzitai@bjtu.edu.cn</a></p><p>虽然本来很想用wang22ti的，但是考虑到学校的嘛，就这样吧。</p><p>为了做操作系统的作业，又安装了VMware和Ubuntu</p><h1 id="18-3-7"><a href="#18-3-7" class="headerlink" title="18-3-7"></a>18-3-7</h1><p>软件工程的老师真是满嘴跑火车，emmmm</p><p>虽然我还是认同一些观点的，但仍然是跑火车。</p><p>和时清讨论了大创爬虫的一些细节，发现mooc学院真是一个好网站。</p><p>论文终于投上去啦！！巨开心，希望有个好结果。</p><p>填了一个巨大的学生调查问卷。</p><p>和许嘉、高时清、张宇翔、夏爱宁、董萧蔓组队虚拟化与云计算。</p><p>jieba库竟然提供了关键词提取，想到上一个项目里我重复造的轮子，几乎哭下来。</p><p>哇，维基百科竟然有提供的<a href="http://wiki.kiwix.org/wiki/Content_in_all_languages/zh-cn" target="_blank" rel="noopener">语料库</a>，良心极了！感动。</p><p>申请了一个ORCID<code>0000-0002-5881-7270</code>，嘿嘿，感觉自己是个科学家。</p><h1 id="18-3-6"><a href="#18-3-6" class="headerlink" title="18-3-6"></a>18-3-6</h1><p>下午和媛媛讨论了大创的最终安排，要拼命了啊</p><p>论文只剩下在系统无法添加基金项目，emmm，明天问一下编辑部吧。</p><p>虽然还是很冷，但是柳条已经隐隐泛着绿色了。</p><p>又学了一点jieba库，明天多学一点。</p><h1 id="18-3-5"><a href="#18-3-5" class="headerlink" title="18-3-5"></a>18-3-5</h1><p>妈的，搬桌子倒垃圾就当志愿算了，</p><p>倒垃圾还被阻拦，也没看见我穿着短袖就让我到楼外去？妈的zz。</p><p>终于把创客空间收拾好了。</p><p>精雕细琢了一天论文，终于可以了！！！</p><p>可是发现还有一些事情，明天干完！</p><p>和吴文睿去健身，</p><p>遇见了余其轩学长，嘿嘿，教练。</p><h1 id="18-3-4"><a href="#18-3-4" class="headerlink" title="18-3-4"></a>18-3-4</h1><p>软卧果然还是比硬卧舒服啊，</p><p>床宽了些， 空间高了一些，有放东西的小架子，有隔间的门……</p><p>睡得还不错。</p><p>收拾东西，理发，拿衣服，买教材，改论文，看《龙珠超》。</p><p>还真是异常丰富的一天呢。</p><p>自在极意。</p><h1 id="18-3-3"><a href="#18-3-3" class="headerlink" title="18-3-3"></a>18-3-3</h1><p>改格式感觉自己office的水平大有精进。。</p><p>中午小卫大哥和二姑来家里吃饭</p><p>晚上10点，又踏上了北上的路，</p><p>新的半年开始了，关键性的。</p><h1 id="18-3-2"><a href="#18-3-2" class="headerlink" title="18-3-2"></a>18-3-2</h1><p>忽然发现时间很紧迫啦，论文，大创，创新创业比赛</p><p>都是在3月，emmm，果然2月过得太舒服了。</p><p>上午清理了一下学校邮箱，腾出2个G，大概可以用一个学期了。</p><p>哇呜，小米6终于更新人脸解锁啦！开心</p><p>带爸爸妈妈看《极乐净土》,嘿嘿。</p><p>处理一堆事情，要开学了事还真不少。</p><p>要根据大改论文格式了，路漫漫啊。</p><p>word真是垃圾。</p><p>买了mathtype，感觉自己是个土豪。</p><h1 id="18-3-1"><a href="#18-3-1" class="headerlink" title="18-3-1"></a>18-3-1</h1><p>哎呀，转眼就3月了。</p><p>好好珍惜每一天啊！</p><p>早起毁一天啊。。</p><p>晚上和孙远爸爸吃饭。</p><p>一天就过去了。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;18-3-31&quot;&gt;&lt;a href=&quot;#18-3-31&quot; class=&quot;headerlink&quot; title=&quot;18-3-31&quot;&gt;&lt;/a&gt;18-3-31&lt;/h1&gt;&lt;p&gt;上午和鑫云到志悦的班级分享经验。&lt;/p&gt;
&lt;p&gt;下午做了部分《操作系统》作业，设计了一个课程报告的模板，&lt;/p&gt;
&lt;p&gt;软件工程的作业开了个头。&lt;/p&gt;
&lt;p&gt;晚上去下棋，互相捡漏子。。&lt;/p&gt;
&lt;p&gt;到楼下还给两个留学生充了20元电费。。&lt;/p&gt;
&lt;p&gt;给高时清买的手机到了，不过屏幕竟然不灵敏。。不科学。。&lt;/p&gt;
&lt;p&gt;好久没写C++了，竟然连&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;都不知道加了。。菜哭&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://wang22ti.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>调用百度翻译API</title>
    <link href="http://wang22ti.com/2018/02/20/%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91API/"/>
    <id>http://wang22ti.com/2018/02/20/调用百度翻译API/</id>
    <published>2018-02-19T16:02:09.000Z</published>
    <updated>2018-02-28T16:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>翻译常用汉语词汇为英语和日语学习</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>一开始还想自己写爬虫，</p><p>但考虑到是百度，以及个人水平，还是算了。</p><p>但意外注意到一个东西：</p><a id="more"></a><p><img src="/2018/02/20/调用百度翻译API/截图2018-02-28_23-51-15.png" alt="截图2018-02-28_23-51-15"></p><p>点开大喜，原来百度已经提供了API在<a href="http://api.fanyi.baidu.com/api/trans/product/index" target="_blank" rel="noopener">翻译开放平台</a>，</p><p>每个月有200万字符的免费通用翻译，真心良心了。</p><p>剩下的就很简单啦，官网里文档支持都很详细。</p><p>python版本我用requests库又写了一个函数，官网的示例有些老旧了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baidu_traslate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    q=<span class="string">'apple'</span>,toLang=<span class="string">'zh'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    fromLang=<span class="string">'auto'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    appid=<span class="string">'****************'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    secretKey=<span class="string">'****************'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line">    url = <span class="string">'http://api.fanyi.baidu.com/api/trans/vip/translate'</span></span><br><span class="line">    salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)</span><br><span class="line"></span><br><span class="line">    sign = appid + q + str(salt) + secretKey</span><br><span class="line">    m = hashlib.md5(sign.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    sign = m.hexdigest()</span><br><span class="line"></span><br><span class="line">    url = url + \</span><br><span class="line">          <span class="string">'?appid='</span> + appid + \</span><br><span class="line">          <span class="string">'&amp;q='</span> + q + \</span><br><span class="line">          <span class="string">'&amp;from='</span> + fromLang + \</span><br><span class="line">          <span class="string">'&amp;to='</span> + toLang + \</span><br><span class="line">          <span class="string">'&amp;salt='</span> + str(salt) + <span class="string">'&amp;sign='</span> + sign</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        text = requests.get(url).text</span><br><span class="line">        ret_dict = json.loads(text)</span><br><span class="line">        ret_dict[<span class="string">'src'</span>] = ret_dict[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'src'</span>]</span><br><span class="line">        ret_dict[<span class="string">'dst'</span>] = ret_dict[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'dst'</span>]</span><br><span class="line">        ret_dict.pop(<span class="string">'trans_result'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret_dict</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'error!'</span>)</span><br></pre></td></tr></table></figure><p>初步接触了md5加密，以前完全没有概念。</p><h1 id="对百度翻译API的改进建议"><a href="#对百度翻译API的改进建议" class="headerlink" title="对百度翻译API的改进建议"></a>对百度翻译API的改进建议</h1><p><strong>返回的内容太简略啦！</strong></p><p><img src="/2018/02/20/调用百度翻译API/截图2018-03-01_00-05-54.png" alt="截图2018-03-01_00-05-54"></p><p>本来是想得到常用词汇的日语翻译，结果发现全是汉字又不知道读音，GG。</p><p>相比之下，有道就好得多，返回信息很丰富：</p><p><img src="/2018/02/20/调用百度翻译API/截图2018-03-01_00-10-07.png" alt="截图2018-03-01_00-10-07"></p><p>不过虽然送了100元，但是完全不免费。。</p><p><img src="/2018/02/20/调用百度翻译API/截图2018-03-01_00-12-48.png" alt="截图2018-03-01_00-12-48"></p><p>啊，总之没有日语注音的事情。</p><p>末了发一下反馈，嘿咻~</p><p><img src="/2018/02/20/调用百度翻译API/截图2018-03-01_00-27-33.png" alt="截图2018-03-01_00-27-33"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;翻译常用汉语词汇为英语和日语学习&lt;/p&gt;
&lt;h1 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h1&gt;&lt;p&gt;一开始还想自己写爬虫，&lt;/p&gt;
&lt;p&gt;但考虑到是百度，以及个人水平，还是算了。&lt;/p&gt;
&lt;p&gt;但意外注意到一个东西：&lt;/p&gt;
    
    </summary>
    
    
      <category term="百度翻译" scheme="http://wang22ti.com/tags/%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/"/>
    
      <category term="API" scheme="http://wang22ti.com/tags/API/"/>
    
      <category term="有道翻译" scheme="http://wang22ti.com/tags/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>小米6连接三星gear手表</title>
    <link href="http://wang22ti.com/2018/02/16/%E5%B0%8F%E7%B1%B36%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%98%9Fgear%E6%89%8B%E8%A1%A8/"/>
    <id>http://wang22ti.com/2018/02/16/小米6连接三星gear手表/</id>
    <published>2018-02-16T15:54:07.000Z</published>
    <updated>2018-02-28T15:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连接手机"><a href="#连接手机" class="headerlink" title="连接手机"></a>连接手机</h1><p>这并不是件容易的事情！<br>需要在Google play下载一堆东西如下，其中</p><p><code>Gear S Plugin</code>和<code>Samsung Accessory Service</code>以及<code>Samsung Push Service</code>是保证Gear和手机互联的基本组件。</p><p><code>Samsung Gear</code>是用来连接和设置的应用软件。</p><p><code>三星健康</code>是查看健康数据以及进行相关设置的应用软件。</p><a id="more"></a><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-18-36-44-620_com.miui.securitycenter - 副本.png" alt="Screenshot_2018-02-28-18-36-44-620_com.miui.securitycenter - 副本"></p><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-23-17-24-685_com.miui.securitycenter.png" alt="Screenshot_2018-02-28-23-17-24-685_com.miui.securitycenter"></p><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-23-18-02-043_com.miui.securitycenter.png" alt="Screenshot_2018-02-28-23-18-02-043_com.miui.securitycenter"></p><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-18-36-44-620_com.miui.securitycenter.png" alt="Screenshot_2018-02-28-18-36-44-620_com.miui.securitycenter"></p><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-18-36-54-622_com.miui.securitycenter.png" alt="Screenshot_2018-02-28-18-36-54-622_com.miui.securitycenter"></p><p>除此之外，还要打开<code>Samsung Accessory Service</code>和<code>Gear S Plugin</code>的自启动管理权限：</p><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-23-33-11-079_com.miui.securitycenter.png" alt="Screenshot_2018-02-28-23-33-11-079_com.miui.securitycenter"></p><p>才能打开<code>Samsung Gear</code>见到如下界面：</p><p><img src="/2018/02/16/小米6连接三星gear手表/Screenshot_2018-02-28-18-37-22-645_com.samsung.android.gearoplugin.png" alt="Screenshot_2018-02-28-18-37-22-645_com.samsung.android.gearoplugin"></p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>一段时间用下来，电池正常可以撑2天，马马虎虎啦。</p><p>应用不少，甚至有游戏，但是都是鸡肋啦。</p><p>不过数据记录得详细准确，支持的运动模式特别丰富，能想到的都有，赞。</p><p>比如之前的小米运动不显示我午睡的情况，</p><p>还会自动记录走路的情况！</p><p>唯一的缺陷是可以加一下esim技术，类似于华为watch2，不过价格可能就上天了吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;连接手机&quot;&gt;&lt;a href=&quot;#连接手机&quot; class=&quot;headerlink&quot; title=&quot;连接手机&quot;&gt;&lt;/a&gt;连接手机&lt;/h1&gt;&lt;p&gt;这并不是件容易的事情！&lt;br&gt;需要在Google play下载一堆东西如下，其中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gear S Plugin&lt;/code&gt;和&lt;code&gt;Samsung Accessory Service&lt;/code&gt;以及&lt;code&gt;Samsung Push Service&lt;/code&gt;是保证Gear和手机互联的基本组件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Samsung Gear&lt;/code&gt;是用来连接和设置的应用软件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;三星健康&lt;/code&gt;是查看健康数据以及进行相关设置的应用软件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="三星" scheme="http://wang22ti.com/tags/%E4%B8%89%E6%98%9F/"/>
    
      <category term="小米" scheme="http://wang22ti.com/tags/%E5%B0%8F%E7%B1%B3/"/>
    
      <category term="手表" scheme="http://wang22ti.com/tags/%E6%89%8B%E8%A1%A8/"/>
    
  </entry>
  
</feed>
